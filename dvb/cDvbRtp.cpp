// cDvbRtp.cpp - dvb transport stream to rtp udp streams - copied from videoLan dvblast
//{{{  includes
#include "cDvbRtp.h"
#include "cDvbUtils.h"
#include "cDvb.h"

#include <vector>

#include <string.h>
#include <unistd.h>

#include <sys/uio.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>

#include <netdb.h>
#include <netinet/in.h>
#include <netinet/ip.h>

// utils
#include "../../shared/fmt/core.h"
#include "../../shared/date/date.h"
#include "../../shared/utils/cLog.h"

using namespace std;
using namespace fmt;
using namespace chrono;
//}}}
//{{{  defines
constexpr int kRtpHeaderSize = 12;

constexpr int kMaxTunerErrorsTillReset = 1000;
constexpr int kMaxEitRetentionMicroSeconds = 500000; // 500 ms

constexpr int kDefaultIPv4Mtu = 1500;
constexpr int kDefaultIPv6Mtu = 1280;

#ifndef IPV6_ADD_MEMBERSHIP
  #define IPV6_ADD_MEMBERSHIP IPV6_JOIN_GROUP
  #define IPV6_DROP_MEMBERSHIP IPV6_LEAVE_GROUP
#endif
//}}}

namespace {
  //{{{  dvb transport stream utils
  constexpr int kTsSize = 188;
  constexpr int kTsHeaderSize = 4;
  //{{{  ts utils
  //{{{
  void ts_init (uint8_t* ts) {
    ts[0] = 0x47;
    ts[1] = 0x0;
    ts[2] = 0x0;
    ts[3] = 0x0;
    }
  //}}}

  bool ts_get_transporterror (const uint8_t* ts) { return !!(ts[1] & 0x80); }

  void ts_set_unitstart (uint8_t* ts) { ts[1] |= 0x40; }
  bool ts_get_unitstart (const uint8_t* ts) { return !!(ts[1] & 0x40); }

  //{{{
  void ts_set_pid (uint8_t* ts, uint16_t pid) {
    ts[1] &= ~0x1f;
    ts[1] |= (pid >> 8) & 0x1f;
    ts[2] = pid & 0xff;
    }
  //}}}
  uint16_t ts_get_pid (const uint8_t* ts) { return ((ts[1] & 0x1f) << 8) | ts[2]; }

  //{{{
  void ts_set_cc (uint8_t* ts, uint8_t cc) {
    ts[3] &= ~0xf;
    ts[3] |= (cc & 0xf);
    }
  //}}}
  uint8_t ts_get_cc (const uint8_t* ts) { return ts[3] & 0xf; }

  void ts_set_payload (uint8_t* ts) { ts[3] |= 0x10; }
  bool ts_has_payload (const uint8_t* ts) { return !!(ts[3] & 0x10); }

  bool ts_has_adaptation (const uint8_t* ts) { return !!(ts[3] & 0x20); }
  uint8_t ts_get_adaptation (const uint8_t* ts) { return ts[4]; }

  bool ts_validate (const uint8_t* ts) { return ts[0] == 0x47; }

  //{{{
  uint8_t* ts_payload (uint8_t* ts) {

    if (!ts_has_payload (ts))
      return ts + kTsSize;

    if (!ts_has_adaptation (ts))
      return ts + kTsHeaderSize;

    return ts + kTsHeaderSize + 1 + ts_get_adaptation (ts);
    }
  //}}}
  //{{{
  uint8_t* ts_section (uint8_t* ts) {

    if (!ts_get_unitstart (ts))
      return ts_payload (ts);

    return ts_payload (ts) + 1; /* pointer_field */
    }
  //}}}
  //{{{
  uint8_t* ts_next_section (uint8_t* ts) {

    uint8_t* payload;

    if (!ts_get_unitstart (ts))
      return ts + kTsSize;

    payload = ts_payload (ts);
    if (payload >= ts + kTsSize)
      return ts + kTsSize;

    return payload + *payload + 1; /* pointer_field */
    }
  //}}}

  bool tsaf_has_pcr (const uint8_t* ts) { return !!(ts[5] & 0x10); }

  bool ts_check_duplicate (uint8_t cc, uint8_t lastCc) { return lastCc == cc; }
  bool ts_check_discontinuity (uint8_t cc, uint8_t lastCc) { return (lastCc + 17 - cc) % 16; }
  //}}}

  constexpr int kPsiHeaderSize = 3;
  constexpr int kPsiHeaderSizeSyntax1 = 8;
  constexpr int kPsiCrcSize = 4;
  constexpr int kPsiMaxSize = 1021;
  constexpr int kPsiPrivateMaxSize = 4093;
  constexpr int kPsiTableMaxSections = 256;
  //{{{  psi utils
  //{{{
  /*****************************************************************************
   * kPsiCrcTable
   *****************************************************************************
   * This table is used to compute a PSI CRC byte per byte instead of bit per
   * bit. It's been generated by 'gen_crc' in the 'misc' directory:
   *
   *   uint32_t table[256];
   *   uint32_t i, j, k;
   *
   *   for(i = 0; i < 256; i++)
   *   {
   *     k = 0;
   *     for (j = (i << 24) | 0x800000; j != 0x80000000; j <<= 1)
   *       k = (k << 1) ^ (((k ^ j) & 0x80000000) ? 0x04c11db7 : 0);
   *     table[i] = k;
   *   }
   *
   * A CRC is computed like this:
   *
   *   initialization
   *   --------------
   *   uint32_t i_crc = 0xffffffff;
   *
   *   for each data byte do
   *   ---------------------
   *   i_crc = (i_crc << 8) ^ s_crc32_table[(i_crc >> 24) ^ (data_byte)];
   *****************************************************************************/
  const uint32_t kPsiCrcTable[256] = {
      0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,
      0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,
      0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
      0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
      0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9,
      0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
      0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011,
      0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,
      0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
      0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,
      0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81,
      0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
      0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49,
      0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
      0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
      0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,
      0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae,
      0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
      0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,
      0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,
      0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
      0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,
      0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066,
      0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
      0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e,
      0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,
      0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
      0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,
      0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,
      0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
      0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686,
      0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,
      0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
      0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
      0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f,
      0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
      0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47,
      0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,
      0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
      0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,
      0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7,
      0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
      0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f,
      0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
      0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
      0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,
      0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f,
      0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
      0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,
      0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,
      0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
      0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,
      0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30,
      0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
      0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088,
      0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,
      0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
      0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,
      0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,
      0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
      0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0,
      0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,
      0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
      0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
  };
  //}}}

  //{{{
  uint8_t* psi_allocate() {
    return (uint8_t*)malloc ((kPsiMaxSize + kPsiHeaderSize) * sizeof(uint8_t));
    }
  //}}}
  //{{{
  uint8_t* psi_private_allocate() {
    return (uint8_t*)malloc ((kPsiPrivateMaxSize + kPsiHeaderSize) * sizeof(uint8_t));
    }
  //}}}

  void psi_set_tableid (uint8_t* section, uint8_t tableId) { section[0] = tableId; }
  uint8_t psi_get_tableid (const uint8_t* section) { return section[0]; }

  void psi_set_syntax (uint8_t* section) { section[1] |= 0x80; }
  bool psi_get_syntax (const uint8_t* section) { return !!(section[1] & 0x80); }

  //{{{
  void psi_init (uint8_t* section, bool syntax) {

    // set reserved bits
    section[1] = 0x70;
    if (syntax) {
      psi_set_syntax (section);
      section[5] = 0xc0;
      }
    }
  //}}}
  //{{{
  void psi_set_length (uint8_t* section, uint16_t length) {

    section[1] &= ~0xf;
    section[1] |= (length >> 8) & 0xf;
    section[2] = length & 0xff;
    }
  //}}}
  uint16_t psi_get_length (const uint8_t* section) { return ((section[1] & 0xf) << 8) | section[2]; }

  //{{{
  void psi_set_tableidext (uint8_t* section, uint16_t tableIdExt) {
    section[3] = tableIdExt >> 8;
    section[4] = tableIdExt & 0xff;
    }
  //}}}
  uint16_t psi_get_tableidext (const uint8_t* section) { return (section[3] << 8) | section[4]; }

  void psi_set_version (uint8_t* section, uint8_t version) { section[5] = (version << 1) | 0xc0; }
  uint8_t psi_get_version (const uint8_t* section) { return (section[5] & 0x3e) >> 1; }

  void psi_set_current (uint8_t* section) { section[5] |= 0x1; }
  bool psi_get_current (const uint8_t* section) { return !!(section[5] & 0x1); }

  void psi_set_section (uint8_t* section, uint8_t sectionNum) { section[6] = sectionNum; }
  uint8_t psi_get_section (const uint8_t* section) { return section[6]; }

  void psi_set_lastsection (uint8_t* section, uint8_t lastSection) { section[7] = lastSection; }
  uint8_t psi_get_lastsection (const uint8_t* section) { return section[7]; }

  //{{{
  void psi_set_crc (uint8_t* section) {

    uint32_t crc = 0xffffffff;
    uint16_t end = (((section[1] & 0xf) << 8) | section[2]) + kPsiHeaderSize - kPsiCrcSize;

    for (uint16_t i = 0; i < end; i++)
      crc = (crc << 8) ^ kPsiCrcTable[(crc >> 24) ^ (section[i])];

    section[end] = crc >> 24;
    section[end+1] = (crc >> 16) & 0xff;
    section[end+2] = (crc >> 8) & 0xff;
    section[end+3] = crc & 0xff;
    }
  //}}}
  //{{{
  bool psi_check_crc (const uint8_t* section) {

    uint32_t crc = 0xffffffff;
    uint16_t end = (((section[1] & 0xf) << 8) | section[2]) + kPsiHeaderSize - kPsiCrcSize;

    for (uint16_t i = 0; i < end; i++)
      crc = (crc << 8) ^ kPsiCrcTable[(crc >> 24) ^ (section[i])];

    return section[end] == (crc >> 24)
           && section[end+1] == ((crc >> 16) & 0xff)
           && section[end+2] == ((crc >> 8) & 0xff)
           && section[end+3] == (crc & 0xff);
    }
  //}}}
  //{{{
  bool psi_validate (const uint8_t* section) {

    if (psi_get_syntax (section) &&
        (psi_get_length (section) < kPsiHeaderSizeSyntax1 - kPsiHeaderSize + kPsiCrcSize))
      return false;

    // only do the CRC check when it is strictly necessary */
    return true;
    }
  //}}}
  //{{{
  bool psi_compare (const uint8_t* section1, const uint8_t* section2) {

    return (psi_get_version (section1) == psi_get_version (section2)) &&
           (psi_get_length (section1) == psi_get_length (section2)) &&
           !memcmp (section1, section2, psi_get_length (section1) + kPsiHeaderSize);
    }
  //}}}

  //{{{
  void psi_assemble_init (uint8_t** psiBuffer, uint16_t* psiBufferUsed) {
    *psiBuffer = NULL;
    *psiBufferUsed = 0;
    }
  //}}}
  //{{{
  void psi_assemble_reset (uint8_t** psiBuffer, uint16_t* psiBufferUsed) {
    free (*psiBuffer);
    psi_assemble_init (psiBuffer, psiBufferUsed);
    }
  //}}}
  //{{{
  bool psi_assemble_empty (uint8_t** psiBuffer, uint16_t* psiBufferUsed) {
    return *psiBuffer == NULL;
    }
  //}}}
  //{{{
  uint8_t* psi_assemble_payload (uint8_t** psiBuffer, uint16_t* psiBufferUsed,
                                 const uint8_t** payload, uint8_t* length) {

    uint16_t remainingSize = kPsiPrivateMaxSize + kPsiHeaderSize - *psiBufferUsed;
    uint16_t copySize = *length < remainingSize ? *length : remainingSize;
    uint8_t* section = NULL;

    if (*psiBuffer == NULL) {
      if (**payload == 0xff) {
        // padding table to the end of buffer
        *length = 0;
        return NULL;
        }
      *psiBuffer = psi_private_allocate();
      }

    memcpy (*psiBuffer + *psiBufferUsed, *payload, copySize);
    *psiBufferUsed += copySize;

    if (*psiBufferUsed >= kPsiHeaderSize) {
      uint16_t sectionSize = psi_get_length(*psiBuffer) + kPsiHeaderSize;
      if (sectionSize > kPsiPrivateMaxSize) {
        // invalid section
        psi_assemble_reset (psiBuffer, psiBufferUsed);
        *length = 0;
        return NULL;
        }

      if (sectionSize <= *psiBufferUsed) {
        section = *psiBuffer;
        copySize -= (*psiBufferUsed - sectionSize);
        *psiBuffer = NULL;
        *psiBufferUsed = 0;
        }
      }

    *payload += copySize;
    *length -= copySize;
    return section;
    }
  //}}}
  //{{{
  void psi_split_end (uint8_t* ts, uint8_t& tsOffset) {

    if (tsOffset != kTsSize) {
      memset (ts + tsOffset, 0xff, kTsSize - tsOffset);
      tsOffset = kTsSize;
      }
    }
  //}}}
  //{{{
  void psi_split_section (uint8_t* ts, uint8_t& tsOffset, const uint8_t* section, uint16_t& sectionOffset) {

    uint16_t sectionLength = psi_get_length (section) + kPsiHeaderSize - sectionOffset;

    if (!tsOffset) {
      ts_init(ts);
      ts_set_payload (ts);
      tsOffset = ts_payload (ts) - ts;
      }

    if (!sectionOffset) {
      if (kTsSize - tsOffset < 2) {
        psi_split_end (ts, tsOffset);
        return;
        }
      if (!ts_get_unitstart (ts)) {
        uint8_t* payload = ts_payload (ts);
        uint8_t payloadLength = tsOffset - (payload - ts);
        if (payloadLength)
          memmove (payload + 1, payload, payloadLength);
        tsOffset++;
        *payload = payloadLength; /* pointer_field */
        ts_set_unitstart (ts);
        }
      }
    uint8_t tsLength = kTsSize - tsOffset;

    uint8_t copy = tsLength < sectionLength ? tsLength : sectionLength;
    memcpy (ts + tsOffset, section + sectionOffset, copy);
    tsOffset += copy;
    sectionOffset += copy;
    }
  //}}}

  //{{{
  void psi_table_init (uint8_t** sections) {

    for (int i = 0; i < kPsiTableMaxSections; i++)
      sections[i] = NULL;
    }
  //}}}
  //{{{
  void psi_table_free (uint8_t** sections) {

    for (int i = 0; i < kPsiTableMaxSections; i++)
      free (sections[i]);
    }
  //}}}

  bool psi_table_validate (uint8_t* const* sections) { return sections[0] != NULL; }
  //{{{
  void psi_table_copy (uint8_t** dest, uint8_t** src) {
    memcpy (dest, src, kPsiTableMaxSections * sizeof(uint8_t*));
    }
  //}}}

  #define psi_table_get_tableid(sections) psi_get_tableid (sections[0])
  #define psi_table_get_version(sections) psi_get_version (sections[0])
  #define psi_table_get_current(sections) psi_get_current (sections[0])
  #define psi_table_get_lastsection(sections) psi_get_lastsection (sections[0])
  #define psi_table_get_tableidext(sections) psi_get_tableidext (sections[0])

  //{{{
  bool psi_table_section (uint8_t** sections, uint8_t* section) {

    uint8_t sectionNum = psi_get_section (section);
    uint8_t lastSection = psi_get_lastsection (section);
    uint8_t version = psi_get_version (section);
    uint16_t tableIdExt = psi_get_tableidext (section);

    free (sections[sectionNum]);
    sections[sectionNum] = section;

    int i;
    for (i = 0; i <= lastSection; i++) {
      uint8_t* p = sections[i];
      if (p == NULL)
        return false;

      if ((psi_get_lastsection (p) != lastSection) ||
          (psi_get_version (p) != version) ||
          (psi_get_tableidext (p) != tableIdExt))
        return false;
      }

    // free spurious, invalid sections
    for (; i < kPsiTableMaxSections; i++) {
      free (sections[i]);
      sections[i] = NULL;
      }

    // a new, full table is available
    return true;
    }
  //}}}
  uint8_t* psi_table_get_section (uint8_t** sections, uint8_t n) { return sections[n]; }
  //{{{
  bool psi_table_compare (uint8_t** sections1, uint8_t** sections2) {

    uint8_t lastSection = psi_table_get_lastsection (sections1);
    if (lastSection != psi_table_get_lastsection (sections2))
      return false;

    for (uint8_t i = 0; i <= lastSection; i++) {
      const uint8_t* section1 = psi_table_get_section (sections1, i);
      const uint8_t* section2 = psi_table_get_section (sections2, i);
      if (!psi_compare (section1, section2))
        return false;
      }

    return true;
    }
  //}}}
  //}}}

  constexpr int kDescHeaderSize = 2;
  constexpr int kDescsHeaderSize = 2;
  constexpr int kDescsMaxSize = 4095;
  //{{{  descriptors
  void desc_set_tag (uint8_t* desc, uint8_t tag) { desc[0] = tag; }
  uint8_t desc_get_tag (const uint8_t* desc) { return desc[0]; }

  void desc_set_length (uint8_t* desc, uint8_t length) { desc[1] = length; }
  uint8_t desc_get_length (const uint8_t* desc) { return desc[1]; }

  //{{{
  uint8_t* descl_get_desc (uint8_t* descl, uint16_t i_length, uint16_t n) {

    uint8_t* desc = descl;
    while (n) {
      if (desc + kDescHeaderSize - descl > i_length)
        return NULL;
      desc += kDescHeaderSize + desc_get_length (desc);
      n--;
      }

    if (desc - descl >= i_length)
      return NULL;

    return desc;
    }
  //}}}
  //{{{
  bool descl_validate (const uint8_t* descl, uint16_t length) {

    const uint8_t* desc = descl;
    while (desc + kDescHeaderSize - descl <= length)
      desc += kDescHeaderSize + desc_get_length (desc);

    return (desc - descl == length);
    }
  //}}}

  //{{{
  void descs_set_length (uint8_t* descs, uint16_t length) {
    descs[0] &= 0xf0;
    descs[0] |= (length >> 8) & 0xf;
    descs[1] = length & 0xff;
    }
  //}}}
  uint16_t descs_get_length (const uint8_t* descs) { return ((descs[0] & 0xf) << 8) | descs[1]; }

  //{{{
  uint8_t* descs_get_desc (uint8_t* descs, uint16_t n) {
    return descl_get_desc (descs + kDescsHeaderSize, descs_get_length (descs), n);
    }
  //}}}
  //{{{
  bool descs_validate (const uint8_t* descs) {
    return descl_validate (descs + kDescsHeaderSize, descs_get_length (descs));
    }
  //}}}
  //}}}

  constexpr int kPatPid = 0x0;
  constexpr int kNitPid = 0x10;
  constexpr int kSdtPid = 0x11;
  constexpr int kEitPid = 0x12;
  constexpr int kRstPid = 0x13;
  constexpr int kTdtPid = 0x14;
  constexpr int kPaddingPid = 8191;
  constexpr int kMaxPids = 8192;
  //{{{  pat - Program Association Table
  #define PAT_TABLE_ID  0x0
  constexpr int PAT_HEADER_SIZE = kPsiHeaderSizeSyntax1;
  #define PAT_PROGRAM_SIZE 4

  #define pat_set_tsid psi_set_tableidext
  #define pat_get_tsid psi_get_tableidext

  //{{{
  void pat_init (uint8_t* pat) {
    psi_init (pat, true);
    psi_set_tableid (pat, PAT_TABLE_ID);
    pat[1] &= ~0x40;
    }
  //}}}
  //{{{
  void pat_set_length (uint8_t* pat, uint16_t patLength) {
    psi_set_length (pat, PAT_HEADER_SIZE + kPsiCrcSize - kPsiHeaderSize + patLength);
    }
  //}}}
  void patn_init (uint8_t* patn) { patn[2] = 0xe0; }

  //{{{
  void patn_set_program (uint8_t* patn, uint16_t program) {
    patn[0] = program >> 8;
    patn[1] = program & 0xff;
    }
  //}}}
  uint16_t patn_get_program (const uint8_t* patn) { return (patn[0] << 8) | patn[1]; }

  //{{{
  void patn_set_pid (uint8_t* patn, uint16_t pid) {
    patn[2] &= ~0x1f;
    patn[2] |= pid >> 8;
    patn[3] = pid & 0xff;
    }
  //}}}
  uint16_t patn_get_pid (const uint8_t* patn) { return ((patn[2] & 0x1f) << 8) | patn[3]; }

  //{{{
  uint8_t* pat_get_program (uint8_t* pat, uint8_t n) {

    uint8_t* patn = pat + PAT_HEADER_SIZE + n * PAT_PROGRAM_SIZE;
    if (patn + PAT_PROGRAM_SIZE - pat > psi_get_length(pat) + kPsiHeaderSize - kPsiCrcSize)
      return NULL;

    return patn;
    }
  //}}}

  //{{{
  bool pat_validate (const uint8_t* pat) {

    if (!psi_get_syntax (pat) || psi_get_tableid (pat) != PAT_TABLE_ID)
      return false;

    if ((psi_get_length (pat) - PAT_HEADER_SIZE + kPsiHeaderSize - kPsiCrcSize) % PAT_PROGRAM_SIZE)
      return false;

    return true;
    }
  //}}}

  //{{{
  uint8_t* pat_table_find_program (uint8_t** sections, uint16_t programNum) {

    uint8_t lastSection = psi_table_get_lastsection (sections);

    for (uint8_t i = 0; i <= lastSection; i++) {
      uint8_t* section = psi_table_get_section (sections, i);
      uint8_t* program;
      int j = 0;
      while ((program = pat_get_program (section, j)) != NULL) {
        j++;
        if (patn_get_program (program) == programNum)
          return program;
        }
      }

    return NULL;
    }
  //}}}
  //{{{
  bool pat_table_validate (uint8_t** sections) {

    uint8_t lastSection = psi_table_get_lastsection (sections);

    for (uint8_t i = 0; i <= lastSection; i++) {
      uint8_t* section = psi_table_get_section (sections, i);
      if (!psi_check_crc (section))
        return false;

      uint8_t* program;
      int j = 0;
      while ((program = pat_get_program (section, j)) != NULL) {
        uint8_t *program2 = pat_table_find_program (sections, patn_get_program (program));
        j++;
        // check that the program number is not already in the table * with another PID
        if (patn_get_pid (program) != patn_get_pid (program2))
          return false;
        }
      }

    return true;
    }
  //}}}
  //}}}
  //{{{  pmt - Program Map Table
  #define PMT_TABLE_ID 0x2
  #define PMT_HEADER_SIZE (kPsiHeaderSizeSyntax1 + 4)
  #define PMT_ES_SIZE 5

  #define pmt_set_program psi_set_tableidext
  #define pmt_get_program psi_get_tableidext

  //{{{
  void pmt_init (uint8_t* pmt) {

    psi_init (pmt, true);
    psi_set_tableid (pmt, PMT_TABLE_ID);
    pmt[1] &= ~0x40;
    psi_set_section (pmt, 0);
    psi_set_lastsection (pmt, 0);
    pmt[8] = 0xe0;
    pmt[10] = 0xf0;
    }
  //}}}
  //{{{
  void pmt_set_length (uint8_t* pmt, uint16_t length) {
    psi_set_length (pmt, PMT_HEADER_SIZE + kPsiCrcSize - kPsiHeaderSize + length);
    }
  //}}}

  //{{{
  void pmt_set_pcrpid (uint8_t* pmt, uint16_t pcrPid) {

    pmt[8] &= ~0x1f;
    pmt[8] |= pcrPid >> 8;
    pmt[9] = pcrPid & 0xff;
    }
  //}}}
  uint16_t pmt_get_pcrpid (const uint8_t* pmt) { return ((pmt[8] & 0x1f) << 8) | pmt[9]; }

  //{{{
  void pmt_set_desclength (uint8_t* pmt, uint16_t length) {

    pmt[10] &= ~0xf;
    pmt[10] |= length >> 8;
    pmt[11] = length & 0xff;
    }
  //}}}
  uint16_t pmt_get_desclength (const uint8_t* pmt) { return ((pmt[10] & 0xf) << 8) | pmt[11]; }

  uint8_t* pmt_get_descs (uint8_t* pmt) { return &pmt[10]; }

  //{{{
  void pmtn_init (uint8_t* pmtn) {

    pmtn[1] = 0xe0;
    pmtn[3] = 0xf0;
    }
  //}}}

  //{{{  stream types
  #define PMT_STREAMTYPE_VIDEO_MPEG1      0x1
  #define PMT_STREAMTYPE_VIDEO_MPEG2      0x2
  #define PMT_STREAMTYPE_AUDIO_MPEG1      0x3
  #define PMT_STREAMTYPE_AUDIO_MPEG2      0x4
  #define PMT_STREAMTYPE_PRIVATE_PSI      0x5
  #define PMT_STREAMTYPE_PRIVATE_PES      0x6
  #define PMT_STREAMTYPE_MHEG             0x7
  #define PMT_STREAMTYPE_DSM_CC           0x8
  #define PMT_STREAMTYPE_H222_1           0x9
  #define PMT_STREAMTYPE_13818_6_A        0xa
  #define PMT_STREAMTYPE_13818_6_B        0xb
  #define PMT_STREAMTYPE_13818_6_C        0xc
  #define PMT_STREAMTYPE_13818_6_D        0xd
  #define PMT_STREAMTYPE_H222_0_AUX       0xe
  #define PMT_STREAMTYPE_AUDIO_ADTS       0xf
  #define PMT_STREAMTYPE_VIDEO_MPEG4      0x10
  #define PMT_STREAMTYPE_AUDIO_LATM       0x11
  #define PMT_STREAMTYPE_SL_PES           0x12
  #define PMT_STREAMTYPE_SL_14496         0x13
  #define PMT_STREAMTYPE_SDP              0x14
  #define PMT_STREAMTYPE_META_PES         0x15
  #define PMT_STREAMTYPE_META_PSI         0x16
  #define PMT_STREAMTYPE_META_DC          0x17
  #define PMT_STREAMTYPE_META_OC          0x18
  #define PMT_STREAMTYPE_META_SDP         0x19
  #define PMT_STREAMTYPE_IPMP_13818_11    0x1a
  #define PMT_STREAMTYPE_VIDEO_AVC        0x1b
  #define PMT_STREAMTYPE_VIDEO_HEVC       0x24
  #define PMT_STREAMTYPE_VIDEO_AVS        0x42
  #define PMT_STREAMTYPE_IPMP             0x7f
  #define PMT_STREAMTYPE_ATSC_A52         0x81
  #define PMT_STREAMTYPE_SCTE_35          0x86
  #define PMT_STREAMTYPE_ATSC_A52E        0x87
  //}}}
  void pmtn_set_streamtype (uint8_t* pmtn, uint8_t streamType) { pmtn[0] = streamType; }
  uint8_t pmtn_get_streamtype (const uint8_t* pmtn) { return pmtn[0]; }
  //{{{
  string pmtGetStreamtypeString (uint8_t streamType) {
  // ISO/IEC 13818-1 | Table 2-36 - Stream type assignments */

    switch (streamType) {
      case 0x0: return "Reserved";
      case 0x01: return "11172-2 video (MPEG-1)";
      case 0x02: return "13818-2 video (MPEG-2)";
      case 0x03: return "11172-3 audio (MPEG-1)";
      case 0x04: return "13818-3 audio (MPEG-2)";
      case 0x05: return "13818-1 private sections";
      case 0x06: return "13818-1 PES private data";
      case 0x07: return "13522 MHEG";
      case 0x08: return "H.222.0/13818-1 Annex A - DSM CC";
      case 0x09: return "H.222.1";
      case 0x0A: return "13818-6 type A";
      case 0x0B: return "13818-6 type B";
      case 0x0C: return "13818-6 type C";
      case 0x0D: return "13818-6 type D";
      case 0x0E: return "H.222.0/13818-1 auxiliary";
      case 0x0F: return "13818-7 Audio with ADTS transport syntax";
      case 0x10: return "14496-2 Visual (MPEG-4 part 2 video)";
      case 0x11: return "14496-3 Audio with LATM transport syntax (14496-3/AMD 1)";
      case 0x12: return "14496-1 SL-packetized or FlexMux stream in PES packets";
      case 0x13: return "14496-1 SL-packetized or FlexMux stream in 14496 sections";
      case 0x14: return "ISO/IEC 13818-6 Synchronized Download Protocol";
      case 0x15: return "Metadata in PES packets";
      case 0x16: return "Metadata in metadata_sections";
      case 0x17: return "Metadata in 13818-6 Data Carousel";
      case 0x18: return "Metadata in 13818-6 Object Carousel";
      case 0x19: return "Metadata in 13818-6 Synchronized Download Protocol";
      case 0x1A: return "13818-11 MPEG-2 IPMP stream";
      case 0x1B: return "H.264/14496-10 video (MPEG-4/AVC)";
      case 0x24: return "H.265 video (MPEG-H/HEVC)";
      case 0x42: return "AVS Video";
      case 0x7F: return "IPMP stream";
      case 0x81: return "ATSC A/52";
      case 0x86: return "SCTE 35 Splice Information Table";
      case 0x87: return "ATSC A/52e";
      default  : return "Unknown";
      }
    }
  //}}}

  //{{{
  void pmtn_set_pid (uint8_t* pmtn, uint16_t pid) {

    pmtn[1] &= ~0x1f;
    pmtn[1] |= pid >> 8;
    pmtn[2] = pid & 0xff;
    }
  //}}}
  uint16_t pmtn_get_pid (const uint8_t* pmtn) { return ((pmtn[1] & 0x1f) << 8) | pmtn[2]; }

  //{{{
  void pmtn_set_desclength (uint8_t* pmtn, uint16_t length) {

    pmtn[3] &= ~0xf;
    pmtn[3] |= length >> 8;
    pmtn[4] = length & 0xff;
    }
  //}}}
  uint16_t pmtn_get_desclength (const uint8_t* pmtn) { return ((pmtn[3] & 0xf) << 8) | pmtn[4]; }

  uint8_t* pmtn_get_descs (uint8_t* pmtn) { return &pmtn[3]; }
  //{{{
  uint8_t* pmt_get_es (uint8_t* pmt, uint8_t n) {

    uint16_t sectionSize = psi_get_length(pmt) + kPsiHeaderSize - kPsiCrcSize;
    uint8_t* pmtn = pmt + PMT_HEADER_SIZE + pmt_get_desclength (pmt);
    if (pmtn - pmt > sectionSize)
      return NULL;

    while (n) {
      if (pmtn + PMT_ES_SIZE - pmt > sectionSize)
        return NULL;
      pmtn += PMT_ES_SIZE + pmtn_get_desclength (pmtn);
      n--;
      }

    if (pmtn - pmt >= sectionSize)
      return NULL;

    return pmtn;
    }
  //}}}

  //{{{
  bool pmt_validate (const uint8_t* pmt) {

    uint16_t sectionSize = psi_get_length(pmt) + kPsiHeaderSize - kPsiCrcSize;

    if (!psi_get_syntax(pmt) || psi_get_section (pmt) ||
        psi_get_lastsection (pmt) || psi_get_tableid (pmt) != PMT_TABLE_ID)
      return false;

    if (!psi_check_crc (pmt))
      return false;

    if ((sectionSize < PMT_HEADER_SIZE) ||
        (sectionSize < PMT_HEADER_SIZE + pmt_get_desclength (pmt)))
      return false;

    if (!descs_validate (pmt + 10))
      return false;

    const uint8_t* pmtn = pmt + PMT_HEADER_SIZE + pmt_get_desclength (pmt);

    while (pmtn + PMT_ES_SIZE - pmt <= sectionSize
           && pmtn + PMT_ES_SIZE + pmtn_get_desclength (pmtn) - pmt <= sectionSize) {
      if (!descs_validate (pmtn + 3))
        return false;

      pmtn += PMT_ES_SIZE + pmtn_get_desclength (pmtn);
      }

    return (pmtn - pmt == sectionSize);
    }
  //}}}
  //}}}
  //{{{  tdt - Time and Date Table
  #define TDT_TABLE_ID  0x70
  #define TDT_HEADER_SIZE (kPsiHeaderSize + 5)
  //}}}
  //{{{  eit - Event Information table
  #define EIT_TABLE_ID_PF_ACTUAL 0x4e
  #define EIT_TABLE_ID_PF_OTHER  0x4f
  #define EIT_TABLE_ID_SCHED_ACTUAL_FIRST 0x50
  #define EIT_TABLE_ID_SCHED_ACTUAL_LAST  0x5f
  #define EIT_TABLE_ID_SCHED_OTHER_FIRST  0x60
  #define EIT_TABLE_ID_SCHED_OTHER_LAST   0x6f

  #define EIT_HEADER_SIZE (kPsiHeaderSizeSyntax1 + 6)
  #define EIT_EVENT_SIZE 12

  #define eit_set_sid psi_set_tableidext
  #define eit_get_sid psi_get_tableidext

  uint16_t eitn_get_desclength (const uint8_t* eitn) { return ((eitn[10] & 0xf) << 8) | eitn[11]; }
  //{{{
  bool eit_validate (const uint8_t* eit) {

    uint16_t sectionSize = psi_get_length (eit) + kPsiHeaderSize - kPsiCrcSize;
    uint8_t tid = psi_get_tableid (eit);

    const uint8_t* eitn;

    if (!psi_get_syntax (eit) ||
        ((tid != EIT_TABLE_ID_PF_ACTUAL) && (tid != EIT_TABLE_ID_PF_OTHER) &&
        !(tid >= EIT_TABLE_ID_SCHED_ACTUAL_FIRST && tid <= EIT_TABLE_ID_SCHED_ACTUAL_LAST) &&
        !(tid >= EIT_TABLE_ID_SCHED_OTHER_FIRST && tid <= EIT_TABLE_ID_SCHED_OTHER_LAST)))
      return false;

    if (!psi_check_crc (eit))
      return false;

    eitn = eit + EIT_HEADER_SIZE;
    while ((eitn + EIT_EVENT_SIZE - eit <= sectionSize) &&
           (eitn + EIT_EVENT_SIZE + eitn_get_desclength (eitn) - eit <= sectionSize)) {
      if (!descs_validate (eitn + 10))
        return false;
      eitn += EIT_EVENT_SIZE + eitn_get_desclength (eitn);
      }

    return (eitn - eit == sectionSize);
    }
  //}}}

  //{{{
  void eit_set_tsid (uint8_t* eit, uint16_t tsId) {
    eit[8] = tsId >> 8;
    eit[9] = tsId & 0xff;
    }
  //}}}
  //{{{
  void eit_set_onid (uint8_t* eit, uint16_t onId) {
    eit[10] = onId >> 8;
    eit[11] = onId & 0xff;
    }
  //}}}
  uint16_t eit_get_onid (const uint8_t* eit) { return (eit[10] << 8) | eit[11]; }

  //}}}
  //{{{  rst - Running Status Table
  #define RST_TABLE_ID 0x71
  #define RST_HEADER_SIZE kPsiHeaderSize
  #define RST_STATUS_SIZE 9
  //}}}
  //{{{  sdt - Service Description Table
  #define SDT_TABLE_ID_ACTUAL 0x42
  #define SDT_TABLE_ID_OTHER 0x46
  #define SDT_HEADER_SIZE (kPsiHeaderSizeSyntax1 + 3)
  #define SDT_SERVICE_SIZE 5

  #define sdt_set_tsid psi_set_tableidext
  #define sdt_get_tsid psi_get_tableidext

  //{{{
  void sdt_init (uint8_t* sdt, bool actual) {

    psi_init (sdt, true);
    psi_set_tableid (sdt, actual ? SDT_TABLE_ID_ACTUAL : SDT_TABLE_ID_OTHER);
    sdt[10] = 0xff;
    }
  //}}}
  //{{{
  void sdt_set_length (uint8_t* sdt, uint16_t sdtLength) {
    psi_set_length (sdt, SDT_HEADER_SIZE + kPsiCrcSize - kPsiHeaderSize + sdtLength);
    }
  //}}}
  //{{{
  void sdt_set_onid (uint8_t* sdt, uint16_t onId) {
    sdt[8] = onId >> 8;
    sdt[9] = onId & 0xff;
    }
  //}}}
  uint16_t sdt_get_onid (const uint8_t* sdt) { return (sdt[8] << 8) | sdt[9]; }

  //{{{
  void sdtn_init (uint8_t* sdtn) {
    sdtn[2] = 0xfc;
    sdtn[3] = 0;
    }
  //}}}
  //{{{
  void sdtn_set_sid (uint8_t* sdtn, uint16_t sid) {
    sdtn[0] = sid >> 8;
    sdtn[1] = sid & 0xff;
    }
  //}}}
  uint16_t sdtn_get_sid (const uint8_t* sdtn) { return (sdtn[0] << 8) | sdtn[1]; }

  void sdtn_set_eitschedule (uint8_t* sdtn) { sdtn[2] |= 0x2; }
  bool sdtn_get_eitschedule (const uint8_t* sdtn) { return !!(sdtn[2] & 0x2); }

  void sdtn_set_eitpresent (uint8_t* sdtn) { sdtn[2] |= 0x1; }
  bool sdtn_get_eitpresent (const uint8_t* sdtn) { return !!(sdtn[2] & 0x1); }

  //{{{
  void sdtn_set_running (uint8_t* sdtn, uint8_t running) {
    sdtn[3] &= 0x1f;
    sdtn[3] |= running << 5;
    }
  //}}}
  uint8_t sdtn_get_running (const uint8_t* sdtn) { return sdtn[3] >> 5; }

  //{{{
  void sdtn_set_desclength (uint8_t* sdtn, uint16_t length) {
    sdtn[3] &= ~0xf;
    sdtn[3] |= (length >> 8) & 0xf;
    sdtn[4] = length & 0xff;
    }
  //}}}
  uint16_t sdtn_get_desclength (const uint8_t* sdtn) { return ((sdtn[3] & 0xf) << 8) | sdtn[4]; }

  uint8_t* sdtn_get_descs (uint8_t* sdtn) { return &sdtn[3]; }

  //{{{
  uint8_t* sdt_get_service (uint8_t* sdt, uint8_t n) {

    uint16_t sectionSize = psi_get_length (sdt) + kPsiHeaderSize - kPsiCrcSize;
    uint8_t* sdtn = sdt + SDT_HEADER_SIZE;

    while (n) {
      if (sdtn + SDT_SERVICE_SIZE - sdt > sectionSize) return NULL;
      sdtn += SDT_SERVICE_SIZE + sdtn_get_desclength (sdtn);
      n--;
      }

    if (sdtn - sdt >= sectionSize)
      return NULL;

    return sdtn;
    }
  //}}}

  //{{{
  bool sdt_validate (const uint8_t* sdt) {

    uint16_t sectionSize = psi_get_length (sdt) + kPsiHeaderSize - kPsiCrcSize;

    if (!psi_get_syntax (sdt) ||
        (psi_get_tableid (sdt) != SDT_TABLE_ID_ACTUAL && psi_get_tableid (sdt) != SDT_TABLE_ID_OTHER))
      return false;

    const uint8_t* sdtn = sdt + SDT_HEADER_SIZE;
    while (sdtn + SDT_SERVICE_SIZE - sdt <= sectionSize
           && sdtn + SDT_SERVICE_SIZE + sdtn_get_desclength (sdtn) - sdt <= sectionSize) {
      if (!descs_validate (sdtn + 3))
        return false;

      sdtn += SDT_SERVICE_SIZE + sdtn_get_desclength (sdtn);
      }

    return (sdtn - sdt == sectionSize);
    }
  //}}}
  //{{{
  uint8_t* sdt_table_find_service (uint8_t** sections, uint16_t sid) {

    uint8_t lastSection = psi_table_get_lastsection (sections);

    for (uint8_t i = 0; i <= lastSection; i++) {
      uint8_t* section = psi_table_get_section (sections, i);
      uint8_t* service;

      int j = 0;
      while ((service = sdt_get_service (section, j)) != NULL) {
        if (sdtn_get_sid (service) == sid)
          return service;
        j++;
        }
      }

    return NULL;
    }
  //}}}
  //{{{
  bool sdt_table_validate (uint8_t** sections) {

    uint8_t lastSection = psi_table_get_lastsection (sections);
    uint16_t i_onid;
    for (uint8_t i = 0; i <= lastSection; i++) {
      uint8_t* section = psi_table_get_section (sections, i);
      uint8_t* service;
      int j = 0;

      if (!psi_check_crc (section))
        return false;

      if (!i)
        i_onid = sdt_get_onid (section);
      else if (sdt_get_onid (section) != i_onid)
        return false;

      while ((service = sdt_get_service (section, j)) != NULL) {
        j++;
        /* check that the service is not already in the table */
        if (sdt_table_find_service (sections, sdtn_get_sid (service)) != service)
          return false;
        }
      }

    return true;
    }
  //}}}

  // service descriptor
  #define DESC48_HEADER_SIZE (kDescHeaderSize + 1)

  void desc48_init (uint8_t* desc) { desc_set_tag (desc, 0x48); }

  void desc48_set_type (uint8_t* desc, uint8_t type) { desc[2] = type; }
  uint8_t desc48_get_type (const uint8_t* desc) { return desc[2]; }

  //{{{
  void desc48_set_provider (uint8_t* desc, const uint8_t* provider, uint8_t length) {

    uint8_t* p = desc + DESC48_HEADER_SIZE;
    p[0] = length;
    memcpy (p + 1, provider, length);
    }
  //}}}
  //{{{
  uint8_t* desc48_get_provider (const uint8_t* desc, uint8_t* length) {

    uint8_t* p = (uint8_t*)desc + DESC48_HEADER_SIZE;
    *length = p[0];
    return p + 1;
    }
  //}}}

  //{{{
  void desc48_set_service (uint8_t* desc, const uint8_t* service, uint8_t length) {

    uint8_t* p = desc + DESC48_HEADER_SIZE + 1 + desc[3];
    p[0] = length;
    memcpy (p + 1, service, length);
    }
  //}}}
  //{{{
  uint8_t* desc48_get_service (const uint8_t* desc, uint8_t* length) {

    uint8_t* p = (uint8_t*)desc + DESC48_HEADER_SIZE + 1 + desc[3];
    *length = p[0];
    return p + 1;
    }
  //}}}

  //{{{
  bool desc48_validate (const uint8_t* desc) {

    uint8_t length = desc_get_length (desc);

    const uint8_t* p = desc + DESC48_HEADER_SIZE;
    p += *p + 1;
    if ((DESC48_HEADER_SIZE + 2 > length + kDescHeaderSize) || (p + 1 - desc > length + kDescHeaderSize))
      return false;

    p += *p + 1;
    if (p - desc > length + kDescHeaderSize)
      return false;

    return true;
    }
  //}}}
  //}}}
  //{{{  nit - Network Information Table
  #define NIT_TABLE_ID_ACTUAL 0x40
  #define NIT_TABLE_ID_OTHER  0x41
  #define NIT_HEADER_SIZE (kPsiHeaderSizeSyntax1 + 2)
  #define NIT_HEADER2_SIZE 2
  #define NIT_TS_SIZE 6

  #define nit_set_nid psi_set_tableidext
  #define nit_get_nid psi_get_tableidext

  //{{{
  void nit_init (uint8_t* nit, bool actual) {

    psi_init (nit, true);
    psi_set_tableid (nit, actual ? NIT_TABLE_ID_ACTUAL : NIT_TABLE_ID_OTHER);
    nit[8] = 0xf0;
    }
  //}}}

  //{{{
  void nit_set_length (uint8_t* nit, uint16_t length) {
    psi_set_length (nit, NIT_HEADER_SIZE + kPsiCrcSize - kPsiHeaderSize + length);
    }
  //}}}
  //{{{
  void nit_set_desclength (uint8_t* nit, uint16_t length) {
    nit[8] &= ~0xf;
    nit[8] |= length >> 8;
    nit[9] = length & 0xff;
    }
  //}}}
  uint16_t nit_get_desclength (const uint8_t* nit) { return ((nit[8] & 0xf) << 8) | nit[9]; }
  uint8_t* nit_get_descs (uint8_t* nit) { return &nit[8]; }

  void nith_init (uint8_t* nith) { nith[0] = 0xf0; }
  //{{{
  void nith_set_tslength (uint8_t* nith, uint16_t length) {
    nith[0] &= ~0xf;
    nith[0] |= length >> 8;
    nith[1] = length & 0xff;
    }
  //}}}
  uint16_t nith_get_tslength (const uint8_t* nith) { return ((nith[0] & 0xf) << 8) | nith[1]; }
  void nitn_init (uint8_t* nitn) { nitn[4] = 0xf0; }

  //{{{
  void nitn_set_tsid (uint8_t* nitn, uint16_t tsId) {
    nitn[0] = tsId >> 8;
    nitn[1] = tsId & 0xff;
    }
  //}}}
  uint16_t nitn_get_tsid (const uint8_t* nitn) { return (nitn[0] << 8) | nitn[1]; }

  //{{{
  void nitn_set_onid (uint8_t* nitn, uint16_t onId) {
    nitn[2] = onId >> 8;
    nitn[3] = onId & 0xff;
    }
  //}}}
  uint16_t nitn_get_onid (const uint8_t* nitn) { return (nitn[2] << 8) | nitn[3]; }

  //{{{
  void nitn_set_desclength (uint8_t* nitn, uint16_t length) {
    nitn[4] &= ~0xf;
    nitn[4] |= length >> 8;
    nitn[5] = length & 0xff;
    }
  //}}}
  uint16_t nitn_get_desclength (const uint8_t* nitn) { return ((nitn[4] & 0xf) << 8) | nitn[5]; }

  uint8_t* nit_get_header2 (uint8_t* nit) { return nit + NIT_HEADER_SIZE + nit_get_desclength(nit); }
  //{{{
  uint8_t* nit_get_ts (uint8_t* nit, uint8_t n) {

    uint16_t sectionSize = psi_get_length(nit) + kPsiHeaderSize - kPsiCrcSize;
    uint8_t* nitn = nit + NIT_HEADER_SIZE + nit_get_desclength(nit) + NIT_HEADER2_SIZE;
    if (nitn - nit > sectionSize)
      return NULL;

    while (n) {
      if (nitn + NIT_TS_SIZE - nit > sectionSize) return NULL;
      nitn += NIT_TS_SIZE + nitn_get_desclength(nitn);
      n--;
      }

    if (nitn - nit >= sectionSize)
      return NULL;
    return nitn;
    }
  //}}}

  //{{{
  bool nit_validate (const uint8_t* nit) {

    uint16_t sectionSize = psi_get_length(nit) + kPsiHeaderSize - kPsiCrcSize;

    if (!psi_get_syntax (nit) ||
        ((psi_get_tableid (nit) != NIT_TABLE_ID_ACTUAL) && (psi_get_tableid (nit) != NIT_TABLE_ID_OTHER)))
      return false;

    if ((sectionSize < NIT_HEADER_SIZE) || (sectionSize < NIT_HEADER_SIZE + nit_get_desclength (nit)))
      return false;

    if (!descs_validate (nit + 8))
      return false;

    const uint8_t* nitn = nit + NIT_HEADER_SIZE + nit_get_desclength (nit);

    if (nith_get_tslength (nitn) != nit + sectionSize - nitn - NIT_HEADER2_SIZE)
      return false;

    nitn += NIT_HEADER2_SIZE;

    while (nitn + NIT_TS_SIZE - nit <= sectionSize
           && nitn + NIT_TS_SIZE + nitn_get_desclength (nitn) - nit <= sectionSize) {
      if (!descs_validate (nitn + 4))
        return false;

      nitn += NIT_TS_SIZE + nitn_get_desclength (nitn);
      }

    return (nitn - nit == sectionSize);
    }
  //}}}

  //{{{
  uint8_t* nit_table_find_ts (uint8_t** sections, uint16_t tsId, uint16_t onId) {

    uint8_t lastSection = psi_table_get_lastsection (sections);
    for (uint8_t i = 0; i <= lastSection; i++) {
      uint8_t* section = psi_table_get_section (sections, i);

      int j = 0;
      uint8_t* ts;
      while ((ts = nit_get_ts (section, j)) != NULL) {
        j++;
        if (nitn_get_tsid (ts) == tsId && nitn_get_onid (ts) == onId)
          return ts;
        }
      }

    return NULL;
    }
  //}}}
  //{{{
  bool nit_table_validate (uint8_t** sections) {

    uint8_t lastSection = psi_table_get_lastsection (sections);
    for (uint8_t i = 0; i <= lastSection; i++) {
      uint8_t* section = psi_table_get_section (sections, i);
      uint8_t* ts;
      int j = 0;

      if (!psi_check_crc (section))
        return false;

      while ((ts = nit_get_ts (section, j)) != NULL) {
        j++;
        // check that the TS is not already in the table
        if (nit_table_find_ts (sections, nitn_get_tsid (ts), nitn_get_onid (ts)) != ts)
          return false;
        }
      }

    return true;
    }
  //}}}

  // network name descriptor
  #define DESC40_HEADER_SIZE  kDescHeaderSize

  void desc40_init (uint8_t* desc) { desc_set_tag (desc, 0x40); }

  void desc40_set_networkname (uint8_t* desc, const uint8_t* network_name, uint8_t length) {
    desc_set_length (desc, length);
    memcpy (desc + 2, network_name, length);
    }
  //}}}

  constexpr int MIN_SECTION_FRAGMENT = kPsiHeaderSizeSyntax1;

  constexpr int MAX_EIT_TABLES = EIT_TABLE_ID_SCHED_ACTUAL_LAST - EIT_TABLE_ID_PF_ACTUAL;

  uint8_t kPadTs[kTsSize] = {
    0x47, 0x1f, 0xff, 0x10, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    };
  //}}}
  //{{{
  struct sEitSections {
    uint8_t* data[kPsiTableMaxSections];
    };
  //}}}
  //{{{
  struct sSid {
    uint16_t mSid;
    uint16_t mPmtPid;
    uint8_t* mCurrentPmt;
    sEitSections mEitTables[MAX_EIT_TABLES];
    };
  //}}}
  //{{{
  struct sRtpPacket {
    sRtpPacket* mNextPacket;
    int64_t mDts;
    int mDepth;
    cTsBlock* mBlocks[];
    };
  //}}}
  //{{{
  class cOutputConfig {
  public:
    cOutputConfig() { initialise(); }

    //{{{
    void initialise() {

      string mDisplayName;

      mOutputDvb = true;
      mOutputEpg = true;

      // identity
      mFamily = AF_UNSPEC;
      mIndexV6 = -1;
      mConnectAddr.ss_family = AF_UNSPEC;
      mBindAddr.ss_family = AF_UNSPEC;

      // output config
      mNetworkId = 0xffff;
      mNetworkName = "";
      mServiceName = "";
      mProviderName = "";

      mSsrc[0] = 0;
      mSsrc[1] = 0;
      mSsrc[2] = 0;
      mSsrc[3] = 0;

      mTtl = 64;
      mTos = 0;
      mMtu = 0;

      // demux config
      mTsId = -1;
      mSid = 0; // 0 if raw mode

      mNumPids = 0;
      mPids = NULL;

      mOnid = 0;
      }
    //}}}

    string mDisplayName;
    uint64_t mOutputDvb;
    uint64_t mOutputEpg;

    int mFamily;
    int mIndexV6;
    struct sockaddr_storage mConnectAddr;
    struct sockaddr_storage mBindAddr;

    uint16_t mNetworkId;
    string mNetworkName;
    string mServiceName;
    string mProviderName;

    uint8_t mSsrc[4];
    int mTtl;
    uint8_t mTos;
    int mMtu;

    int mTsId;
    uint16_t mSid;

    int mNumPids;
    uint16_t* mPids;

    uint16_t mOnid;
    };
  //}}}
  //{{{
  class cOutput {
  public:
    //{{{
    bool initialise (const cOutputConfig* outputConfig) {

      socklen_t sockaddrLen =
        (outputConfig->mFamily == AF_INET) ? sizeof(struct sockaddr_in) : sizeof(struct sockaddr_in6);

      mConfig.initialise();

      mSocket = 0;
      mPackets = NULL;
      mLastPacket = NULL;
      mPacketLifo = NULL;
      mPacketCount = 0;
      mSeqnum = rand() & 0xffff;

      mPatVersion = rand() & 0xff;
      mPatContinuity = rand() & 0xf;
      mPatSection = NULL;

      mPmtVersion = rand() & 0xff;
      mPmtContinuity = rand() & 0xf;
      mPmtSection = NULL;

      mNitVersion = rand() & 0xff;
      mNitContinuity = rand() & 0xf;
      mNitSection = NULL;

      mSdtVersion = rand() & 0xff;
      mSdtContinuity = rand() & 0xf;
      mSdtSection = NULL;

      mEitTsBuffer = NULL;
      mEitTsBufferOffset = 0;
      mEitContinuity = rand() & 0xf;

      mTsId = 0;
      mPcrPid = 0;

      // init socket-related fields
      mConfig.mFamily = outputConfig->mFamily;
      memcpy (&mConfig.mConnectAddr, &outputConfig->mConnectAddr, sizeof(struct sockaddr_storage));
      memcpy (&mConfig.mBindAddr, &outputConfig->mBindAddr, sizeof(struct sockaddr_storage));
      mConfig.mIndexV6 = outputConfig->mIndexV6;

      mSocket = socket (outputConfig->mFamily, SOCK_DGRAM, IPPROTO_UDP);
      if (mSocket < 0) {
        //{{{  return error
        cLog::log (LOGERROR, "couldn't create socket %s", strerror (errno));
        return false;
        }
        //}}}

      int ret = 0;
      if (outputConfig->mBindAddr.ss_family != AF_UNSPEC) {
        //{{{  bind socket, set multicast
        if (bind (mSocket, (struct sockaddr*)&outputConfig->mBindAddr, sockaddrLen) < 0)
          cLog::log (LOGINFO, "couldn't bind socket %s", strerror (errno));

        if (outputConfig->mFamily == AF_INET) {
          struct sockaddr_in* connectAddr = (struct sockaddr_in*)&mConfig.mConnectAddr;
          struct sockaddr_in* bindAddr = (struct sockaddr_in*)&mConfig.mBindAddr;

          if (IN_MULTICAST(ntohl (connectAddr->sin_addr.s_addr)))
            ret = setsockopt (mSocket, IPPROTO_IP, IP_MULTICAST_IF,
                              (void*)&bindAddr->sin_addr.s_addr, sizeof(bindAddr->sin_addr.s_addr));
          }
        }
        //}}}
      if (outputConfig->mFamily == AF_INET6 && outputConfig->mIndexV6 != -1) {
        //{{{  set ipv6 stuff
        struct sockaddr_in6* p_addr = (struct sockaddr_in6*)&mConfig.mConnectAddr;
        if (IN6_IS_ADDR_MULTICAST(&p_addr->sin6_addr))
          ret = setsockopt (mSocket, IPPROTO_IPV6, IPV6_MULTICAST_IF,
                            (void*)&outputConfig->mIndexV6, sizeof(outputConfig->mIndexV6));
        }
        //}}}
      if (ret == -1)
        cLog::log (LOGINFO, "couldn't join multicast address %s", strerror (errno));
      if (connect (mSocket, (struct sockaddr*)&mConfig.mConnectAddr, sockaddrLen) < 0) {
        //{{{  return error
        cLog::log (LOGERROR, "couldn't connect socket %s", strerror (errno));
        close (mSocket);
        return false;
        }
        //}}}
      return true;
      }
    //}}}

    int getBlockCount() { return (mConfig.mMtu - kRtpHeaderSize) / kTsSize; }
    string getInfoString() { return format ("{}:{:4} {:4}:{:4}:{:4} {:12} {}",
                                            mConfig.mDisplayName, mConfig.mSid,
                                            mVidPid, mAudPid, mSubPid, mNameString, mNowString); }

    //{{{
    sRtpPacket* packetNew() {

      sRtpPacket* packet;

      if (mPacketCount) {
        packet = mPacketLifo;
        mPacketLifo = packet->mNextPacket;
        mPacketCount--;
        }
      else
        packet = (sRtpPacket*)malloc (sizeof(sRtpPacket) + getBlockCount() * sizeof(cTsBlock*));

      packet->mDepth = 0;
      packet->mNextPacket = NULL;

      return packet;
      }
    //}}}
    //{{{
    void packetDelete (sRtpPacket* packet) {

      if (mPacketCount >= kMaxOutputPackets) {
        free (packet);
        return;
        }

      packet->mNextPacket = mPacketLifo;
      mPacketLifo = packet;
      mPacketCount++;
      }
    //}}}
    //{{{
    void packetCleanup() {

      while (mPacketCount) {
        sRtpPacket* packet = mPacketLifo;
        mPacketLifo = packet->mNextPacket;
        free (packet);

        mPacketCount--;
        }
      }
    //}}}

    // vars
    cOutputConfig mConfig;

    // output
    int mSocket = -1;

    uint16_t mSeqnum = 0;
    sRtpPacket* mLastPacket = NULL;
    sRtpPacket* mPacketLifo = NULL;
    sRtpPacket* mPackets = NULL;

    // demux
    uint16_t mTsId = 0;
    uint16_t mPcrPid = 0;

    uint16_t mAudPid = 0;
    uint16_t mVidPid = 0;
    uint16_t mSubPid = 0;

    uint8_t mPatVersion = 0;
    uint8_t mPatContinuity = 0;
    uint8_t* mPatSection = NULL;

    uint8_t mPmtVersion = 0;
    uint8_t mPmtContinuity = 0;
    uint8_t* mPmtSection = NULL;

    uint8_t mNitVersion = 0;
    uint8_t mNitContinuity = 0;
    uint8_t* mNitSection = NULL;

    uint8_t mSdtVersion = 0;
    uint8_t mSdtContinuity = 0;
    uint8_t* mSdtSection = NULL;

    uint8_t mEitContinuity = 0;
    uint8_t mEitTsBufferOffset = 0;
    cTsBlock* mEitTsBuffer = NULL;
    int nEitSectionsCount = 0;

    string mNameString;
    string mNowString;

  private:
    static constexpr int kMaxOutputPackets = 100;

    unsigned int mPacketCount = 0;
    };
  //}}}
  //{{{
  struct sTsPid {
    int mRefCount;
    int mPsiRefCount;

    int mDemuxFd;

    bool mPes;
    int8_t mLastContinuity;

    // bitstream PSI section gathering
    uint16_t mPsiBufferUsed;
    uint8_t* mPsiBuffer;

    int mNumOutputs;
    cOutput** mOutputs;
    };
  //}}}
  //{{{  vars
  cDvb* mDvb;
  cTsBlockPool* mBlockPool;

  // time
  int64_t mLastDts = -1;

  // tuner
  bool mBudgetMode = false;
  int mBudgetDemuxFd;

  uint64_t mNumPackets = 0;
  uint64_t mNumInvalids = 0;
  uint64_t mNumDiscontinuities = 0;
  uint64_t mNumErrors = 0;
  int mTunerErrors = 0;

  // pids
  sTsPid mTsPids[kMaxPids];

  // sids
  int mNumSids = 0;
  sSid** mSids = NULL;

  // tables
  uint8_t* mCurrentPatSections[kPsiTableMaxSections];
  uint8_t* mNextPatSections[kPsiTableMaxSections];
  uint8_t* mCurrentNitSections[kPsiTableMaxSections];
  uint8_t* mNexttNitSections[kPsiTableMaxSections];
  uint8_t* mCurrentSdtSections[kPsiTableMaxSections];
  uint8_t* mNextSdtSections[kPsiTableMaxSections];

  system_clock::time_point mTime;
  string mTimeString;

  // outputs
  vector <cOutput*> mOutputs;
  //}}}

  //{{{
  int64_t mdate() {
  // use POSIX monotonic clock if available
  // - run-time fallback to real-time clock

    struct timespec ts;
    if (clock_gettime (CLOCK_MONOTONIC, &ts) == EINVAL)
      (void)clock_gettime (CLOCK_REALTIME, &ts);

    return ((int64_t)ts.tv_sec * (int64_t)1000000) + (int64_t)(ts.tv_nsec / 1000);
    }
  //}}}
  //{{{  demux utils
  //{{{
  bool isIn (const uint16_t* pids, int numPids, uint16_t pidNum) {

    for (int i = 0; i < numPids; i++)
      if (pidNum == pids[i])
        return true;

    return false;
    }
  //}}}
  //{{{
  bool pidCarriesPES (const uint8_t* es) {

    uint8_t i_type = pmtn_get_streamtype (es);
    switch (i_type) {
      case 0x1: // video MPEG-1
      case 0x2: // video
      case 0x3: // audio MPEG-1
      case 0x4: // audio
      case 0x6: // private PES data
      case 0xf: // audio AAC
      case 0x10: // video MPEG-4
      case 0x11: // audio AAC LATM
      case 0x1b: // video H264
      case 0x24: // video H265
      case 0x81: // ATSC A/52
      case 0x87: // ATSC Enhanced A/52
        return true;
        break;

      default:
        return false;
        break;
      }
    }
  //}}}
  //{{{
  bool pidWouldBeSelected (uint8_t* es) {

    uint8_t i_type = pmtn_get_streamtype (es);
    switch (i_type) {
      case 0x1: // video MPEG-1
      case 0x2: // video
      case 0x3: // audio MPEG-1
      case 0x4: // audio
      case 0xf: // audio AAC ADTS
      case 0x10: // video MPEG-4
      case 0x11: // audio AAC LATM
      case 0x1b: // video H264
      case 0x24: // video H265
      case 0x81: // ATSC A/52
      case 0x87: // ATSC Enhanced A/52
        return true;
        break;

      case 0x6: {
        uint16_t j = 0;
        const uint8_t* desc;
        while ((desc = descs_get_desc (pmtn_get_descs (es), j))) {
          uint8_t i_tag = desc_get_tag (desc);
          j++;

          if (i_tag == 0x46 // VBI + teletext
              || i_tag == 0x56 // teletext
              || i_tag == 0x59 // dvbsub
              || i_tag == 0x6a // A/52
              || i_tag == 0x7a // Enhanced A/52
              || i_tag == 0x7b // DCA
              || i_tag == 0x7c // AAC
              )
            return true;
          }
        break;
        }

      default:
        break;
      }

    // FIXME: also parse IOD
    return false;
    }
  //}}}
  //{{{
  string getPidDesc (uint16_t pidNum, uint16_t& sidNum) {

    // Simple cases
    switch (pidNum) {
      case kPatPid: return "PAT";
      case kSdtPid: return "SDT";
      case kEitPid: return "EPG";
      case kTdtPid: return "TDT/TOT";
      }

    // detect NIT pid
    int j;
    uint8_t lastSection;
    uint16_t nitPid = kNitPid;
    if (psi_table_validate (mCurrentPatSections)) {
      lastSection = psi_table_get_lastsection (mCurrentPatSections);
      for (int i = 0; i <= lastSection; i++) {
        uint8_t* section = psi_table_get_section (mCurrentPatSections, i);
        uint8_t* program;
        j = 0;
        while ((program = pat_get_program (section, j++))) {
          // Programs with PID == 0 are actually NIT
          if (patn_get_program (program) == 0) {
            nitPid = patn_get_pid (program);
            break;
            }
          }
        }
      }

    // detect streams in PMT
    uint16_t pcrPid = 0;
    for (int k = 0; k < mNumSids; k++) {
      sSid* sid = mSids[k];
      if (sid->mPmtPid == pidNum) {
        sidNum = sid->mSid;
        return "PMT";
        }

      if (sid->mSid && sid->mCurrentPmt) {
        uint8_t* mCurrentPmt = sid->mCurrentPmt;
        uint8_t* p_current_es;

        // The PCR PID can be alone or PCR can be carried in some other PIDs (mostly video)
        // so just remember the pid and if it is alone it will be reported as PCR, otherwise
        // stream type of the PID will be reported
        if (pidNum == pmt_get_pcrpid (mCurrentPmt)) {
          sidNum = sid->mSid;
          pcrPid = pmt_get_pcrpid (mCurrentPmt);
          }

        // Detect stream types
        j = 0;
        while ((p_current_es = pmt_get_es (mCurrentPmt, j++))) {
          if (pmtn_get_pid (p_current_es) == pidNum) {
            sidNum = sid->mSid;
            return pmtGetStreamtypeString (pmtn_get_streamtype (p_current_es));
            }
          }
        }
      }

    // Are there any other PIDs?
    if (pidNum == nitPid)
      return "NIT";

    if (pidNum == pcrPid)
      return "PCR";

    return "...";
    }
  //}}}

  //{{{
  sSid* findSid (int16_t sidNum) {

    for (int i = 0; i < mNumSids; i++) {
      sSid* sid = mSids[i];
      if (sid->mSid == sidNum)
        return sid;
      }
    return NULL;
    }
  //}}}
  //{{{
  void getPids (uint16_t** wantedPids, int* numWantedPids, uint16_t* wantedPcrPid,
                uint16_t sidNum, const uint16_t* pids, int numPids) {

    *wantedPcrPid = 0;
    if (numPids || sidNum == 0) {
      *numWantedPids = numPids;
      *wantedPids = (uint16_t*)malloc (sizeof(uint16_t) * numPids);
      memcpy (*wantedPids, pids, sizeof(uint16_t) * numPids);
      if (sidNum == 0)
        return;
      }
    else {
      *numWantedPids = 0;
      *wantedPids = NULL;
      }

    sSid* sid = findSid (sidNum);
    if (sid == NULL)
      return;

    uint8_t* pmt = sid->mCurrentPmt;
    uint16_t pmtPid = sid->mPmtPid;
    if (pmt == NULL) {
      cLog::log (LOGINFO, "no current PMT on sid %d", sidNum);
      return;
      }

    uint16_t pcrPid = pmt_get_pcrpid (pmt);
    uint8_t j = 0;
    uint8_t* es;
    while ((es = pmt_get_es (pmt, j))) {
      j++;
      uint16_t pidNum = pmtn_get_pid (es);
      bool select;
      if (numPids)
        select = isIn (pids, numPids, pidNum);
      else {
        select = pidWouldBeSelected (es);
        if (select) {
          *wantedPids = (uint16_t*)realloc (*wantedPids, (*numWantedPids + 1) * sizeof(uint16_t));
          (*wantedPids)[(*numWantedPids)++] = pidNum;
          }
        }
      }

    if ((pcrPid != kPaddingPid) &&
        (pcrPid != pmtPid) &&
        !isIn (*wantedPids, *numWantedPids, pcrPid)) {
      *wantedPids = (uint16_t*)realloc (*wantedPids, (*numWantedPids + 1) * sizeof(uint16_t));
      (*wantedPids)[(*numWantedPids)++] = pcrPid;

      // We only need the PCR packets of this stream (incomplete)
      *wantedPcrPid = pcrPid;
      cLog::log (LOGINFO, "Requesting partial PCR PID %d", pcrPid);
      }

    }
  //}}}

  //{{{
  void setPid (uint16_t pidNum) {

    mTsPids[pidNum].mRefCount++;

    if (!mBudgetMode
        && mTsPids[pidNum].mRefCount
        && mTsPids[pidNum].mDemuxFd == -1)
      mTsPids[pidNum].mDemuxFd = mDvb->setFilter (pidNum);
    }
  //}}}
  //{{{
  void unsetPid (uint16_t pidNum) {

    mTsPids[pidNum].mRefCount--;

    if (!mBudgetMode
        && !mTsPids[pidNum].mRefCount
        && mTsPids[pidNum].mDemuxFd != -1) {
      mDvb->unsetFilter (mTsPids[pidNum].mDemuxFd, pidNum);
      mTsPids[pidNum].mDemuxFd = -1;
      }
    }
  //}}}
  //{{{
  void startPid (cOutput* output, uint16_t pidNum) {

    int j;
    for (j = 0; j < mTsPids[pidNum].mNumOutputs; j++)
      if (mTsPids[pidNum].mOutputs[j] == output)
        break;

    if (j == mTsPids[pidNum].mNumOutputs) {
      for (j = 0; j < mTsPids[pidNum].mNumOutputs; j++)
        if (mTsPids[pidNum].mOutputs[j] == NULL)
          break;

      if (j == mTsPids[pidNum].mNumOutputs) {
        mTsPids[pidNum].mNumOutputs++;
        mTsPids[pidNum].mOutputs =
          (cOutput**)realloc (mTsPids[pidNum].mOutputs, sizeof(cOutput*) * mTsPids[pidNum].mNumOutputs);
        }

      mTsPids[pidNum].mOutputs[j] = output;
      setPid (pidNum);
      }
    }
  //}}}
  //{{{
  void stopPid (cOutput* output, uint16_t pidNum) {

    int j;
    for (j = 0; j < mTsPids[pidNum].mNumOutputs; j++)
      if (mTsPids[pidNum].mOutputs[j])
        if (mTsPids[pidNum].mOutputs[j] == output)
          break;

    if (j != mTsPids[pidNum].mNumOutputs) {
      mTsPids[pidNum].mOutputs[j] = NULL;
      unsetPid (pidNum);
      }
    }
  //}}}
  //{{{
  void selectPid (uint16_t sidNum, uint16_t pidNum, bool pcr) {

    for (auto output : mOutputs)
      if (output->mConfig.mSid == sidNum) {
        if (output->mConfig.mNumPids &&
            !isIn (output->mConfig.mPids, output->mConfig.mNumPids, pidNum)) {
          if (pcr)
            output->mPcrPid = pidNum;
          else
            continue;
          }
        startPid (output, pidNum);
        }
    }
  //}}}
  //{{{
  void unselectPid (uint16_t sidNum, uint16_t pidNum) {

    for (auto output : mOutputs)
      if ((output->mConfig.mSid == sidNum) && !output->mConfig.mNumPids)
        stopPid (output, pidNum);
    }
  //}}}

  //{{{
  void selectPMT (uint16_t sidNum, uint16_t pidNum) {

    mTsPids[pidNum].mPsiRefCount++;
    mTsPids[pidNum].mPes = false;
    setPid (pidNum);
    }
  //}}}
  //{{{
  void unselectPMT (uint16_t sidNum, uint16_t pidNum) {

    mTsPids[pidNum].mPsiRefCount--;
    if (!mTsPids[pidNum].mPsiRefCount)
      psi_assemble_reset (&mTsPids[pidNum].mPsiBuffer, &mTsPids[pidNum].mPsiBufferUsed);

    unsetPid (pidNum);
    }
  //}}}

  //{{{
  void copyDescriptors (uint8_t* descs, uint8_t* currentDescs) {

    descs_set_length (descs, kDescsMaxSize);

    uint16_t k = 0;
    uint16_t j = 0;
    const uint8_t* currentDesc;
    while ((currentDesc = descs_get_desc (currentDescs, j))) {
      uint8_t tag = desc_get_tag (currentDesc);
      j++;
      if (tag == 0x9)
        continue;

      uint8_t* desc = descs_get_desc (descs, k);
      if (desc == NULL)
        continue; // This shouldn't happen

      k++;
      memcpy (desc, currentDesc, kDescHeaderSize + desc_get_length (currentDesc));
      }

    uint8_t* desc = descs_get_desc (descs, k);
    if (desc == NULL)
      // This shouldn't happen if the incoming PMT is valid
      descs_set_length (descs, 0);
    else
      descs_set_length (descs, desc - descs - kDescsHeaderSize);
    }
  //}}}
  //{{{
  void newPAT (cOutput* output) {

    free (output->mPatSection);

    output->mPatSection = NULL;
    output->mPatVersion++;

    if (!output->mConfig.mSid)
      return;
    if (!psi_table_validate (mCurrentPatSections))
      return;

    const uint8_t* p_program = pat_table_find_program (mCurrentPatSections, output->mConfig.mSid);
    if (p_program == NULL)
      return;

    uint8_t* p = output->mPatSection = psi_allocate();
    pat_init (p);
    psi_set_length (p, kPsiMaxSize);
    pat_set_tsid (p, output->mTsId);
    psi_set_version (p, output->mPatVersion);
    psi_set_current (p);
    psi_set_section (p, 0);
    psi_set_lastsection (p, 0);

    uint8_t k = 0;
    if (output->mConfig.mOutputDvb) {
      // NIT pf
      p = pat_get_program (output->mPatSection, k++);
      patn_init (p);
      patn_set_program (p, 0);
      patn_set_pid (p, kNitPid);
      }

    p = pat_get_program (output->mPatSection, k++);
    patn_init (p);
    patn_set_program (p, output->mConfig.mSid);

    patn_set_pid (p, patn_get_pid (p_program));

    p = pat_get_program (output->mPatSection, k);
    pat_set_length (output->mPatSection,  p - output->mPatSection - PAT_HEADER_SIZE);
    psi_set_crc (output->mPatSection);
    }
  //}}}
  //{{{
  void newPMT (cOutput* output) {

    free (output->mPmtSection);

    output->mPmtSection = NULL;
    output->mPmtVersion++;
    if (!output->mConfig.mSid)
      return;

    sSid* sid = findSid (output->mConfig.mSid);
    if (sid == NULL)
      return;

    if (sid->mCurrentPmt == NULL)
      return;

    uint8_t* currentPmt = sid->mCurrentPmt;
    uint8_t* p = output->mPmtSection = psi_allocate();
    pmt_init (p);
    psi_set_length (p, kPsiMaxSize);
    pmt_set_program (p, output->mConfig.mSid);

    psi_set_version (p, output->mPmtVersion);
    psi_set_current (p);
    pmt_set_desclength (p, 0);
    copyDescriptors (pmt_get_descs (p), pmt_get_descs (currentPmt));

    uint16_t j = 0;
    uint16_t k = 0;
    uint8_t* currentEs;
    while ((currentEs = pmt_get_es (currentPmt, j))) {
      uint16_t pidNum = pmtn_get_pid (currentEs);
      j++;
      if ((output->mConfig.mNumPids || !pidWouldBeSelected (currentEs))
          && !isIn (output->mConfig.mPids, output->mConfig.mNumPids, pidNum))
        continue;

      uint8_t* es = pmt_get_es (p, k);
      if (es == NULL)
        continue; // This shouldn't happen

      k++;
      pmtn_init (es);
      pmtn_set_streamtype (es, pmtn_get_streamtype (currentEs));
      pmtn_set_pid (es, pidNum);
      pmtn_set_desclength (es, 0);
      copyDescriptors (pmtn_get_descs (es), pmtn_get_descs (currentEs));
      }

    // Do the pcr pid after everything else as it may have been remapped
    uint16_t pcrPid = pmt_get_pcrpid (currentPmt);

    pmt_set_pcrpid (p, pcrPid);
    uint8_t* es = pmt_get_es (p, k);
    if (es == NULL)
      // This shouldn't happen if the incoming PMT is valid
      pmt_set_length (p, 0);
    else
      pmt_set_length (p, es - p - PMT_HEADER_SIZE);
    psi_set_crc (p);
    }
  //}}}
  //{{{
  void newNIT (cOutput* output) {

    free (output->mNitSection);

    uint8_t* nitSection = psi_allocate();
    output->mNitSection = nitSection;
    output->mNitVersion++;

    nit_init (nitSection, true);
    nit_set_length (nitSection, kPsiMaxSize);
    nit_set_nid (nitSection, output->mConfig.mNetworkId);
    psi_set_version (nitSection, output->mNitVersion);
    psi_set_current (nitSection);
    psi_set_section (nitSection, 0);
    psi_set_lastsection (nitSection, 0);

    if (output->mConfig.mNetworkName.size()) {
      nit_set_desclength (nitSection, kDescsMaxSize);
      uint8_t* descs = nit_get_descs (nitSection);
      uint8_t* desc = descs_get_desc (descs, 0);
      desc40_init (desc);
      desc40_set_networkname (desc, (const uint8_t*)output->mConfig.mNetworkName.c_str(),
                                     output->mConfig.mNetworkName.size());
      desc = descs_get_desc (descs, 1);
      descs_set_length (descs, desc - descs - kDescsHeaderSize);
      }
    else
      nit_set_desclength (nitSection, 0);

    uint8_t* header2 = nit_get_header2 (nitSection);
    nith_init (header2);
    nith_set_tslength (header2, NIT_TS_SIZE);

    uint8_t* ts = nit_get_ts (nitSection, 0);
    nitn_init (ts);
    nitn_set_tsid (ts, output->mTsId);
    if (output->mConfig.mOnid)
      nitn_set_onid (ts, output->mConfig.mOnid);
    else
      nitn_set_onid (ts, output->mConfig.mNetworkId);
    nitn_set_desclength (ts, 0);

    ts = nit_get_ts (nitSection, 1);
    if (ts == NULL)
      // This shouldn't happen
      nit_set_length (nitSection, 0);
    else
      nit_set_length (nitSection, ts - nitSection - NIT_HEADER_SIZE);

    psi_set_crc (output->mNitSection);
    }
  //}}}
  //{{{
  void newSDT (cOutput* output) {

    free (output->mSdtSection);

    output->mSdtSection = NULL;
    output->mSdtVersion++;
    if (!output->mConfig.mSid)
      return;
    if (!psi_table_validate (mCurrentSdtSections))
      return;

    uint8_t* currentService = sdt_table_find_service (mCurrentSdtSections, output->mConfig.mSid);
    if (currentService == NULL) {
      if (output->mPatSection && pat_get_program (output->mPatSection, 0) == NULL) {
        // Empty PAT and no SDT anymore
        free (output->mPatSection);
        output->mPatSection = NULL;
        output->mPatVersion++;
        }
      return;
      }

    uint8_t* sdtSection = psi_allocate();
    output->mSdtSection = sdtSection;
    sdt_init (sdtSection, true);
    sdt_set_length (sdtSection, kPsiMaxSize);
    sdt_set_tsid (sdtSection, output->mTsId);
    psi_set_version (sdtSection, output->mSdtVersion);
    psi_set_current (sdtSection);
    psi_set_section (sdtSection, 0);
    psi_set_lastsection (sdtSection, 0);
    if (output->mConfig.mOnid)
      sdt_set_onid (sdtSection, output->mConfig.mOnid);
    else
      sdt_set_onid (sdtSection, sdt_get_onid (psi_table_get_section (mCurrentSdtSections, 0)));

    uint8_t* service = sdt_get_service (sdtSection, 0);
    sdtn_init (service);
    sdtn_set_sid (service, output->mConfig.mSid);

    // We always forward EITpf
    if (sdtn_get_eitpresent (currentService))
      sdtn_set_eitpresent (service);

    if (output->mConfig.mOutputEpg && sdtn_get_eitschedule (currentService))
      sdtn_set_eitschedule (service);

    sdtn_set_running (service, sdtn_get_running (currentService));

    // Do not set free_ca
    sdtn_set_desclength (service, sdtn_get_desclength (currentService));

    if (!output->mConfig.mProviderName.size() && !output->mConfig.mServiceName.size()) {
        // Copy all descriptors unchanged
        memcpy (descs_get_desc (sdtn_get_descs (service), 0),
                descs_get_desc (sdtn_get_descs (currentService), 0),
                sdtn_get_desclength (currentService));
      }
    else {
      int j = 0;
      int totalDescLen = 0;
      uint8_t* desc;
      uint8_t* newDesc = descs_get_desc (sdtn_get_descs (service), 0);
      while ((desc = descs_get_desc (sdtn_get_descs (currentService), j++))) {
        // Regenerate descriptor 48 (service name)
        if (desc_get_tag (desc) == 0x48 && desc48_validate (desc)) {
          uint8_t oldProviderLen;
          uint8_t oldServiceLen;
          uint8_t newDescLen = 3; // 1 byte - type, 1 byte provider_len, 1 byte service_len
          const uint8_t* oldProvider = desc48_get_provider (desc, &oldProviderLen);
          const uint8_t* oldService = desc48_get_service (desc, &oldServiceLen);

          desc48_init (newDesc);
          desc48_set_type (newDesc, desc48_get_type (desc));

          if (output->mConfig.mProviderName.size()) {
            desc48_set_provider (newDesc, (const uint8_t*)output->mConfig.mProviderName.c_str(),
                                           output->mConfig.mProviderName.size());
            newDescLen += output->mConfig.mProviderName.size();
            }
          else {
            desc48_set_provider (newDesc, oldProvider, oldProviderLen);
            newDescLen += oldProviderLen;
            }
          if (output->mConfig.mServiceName.size()) {
            desc48_set_service (newDesc, (const uint8_t*)output->mConfig.mServiceName.c_str(),
                                          output->mConfig.mServiceName.size());
            newDescLen += output->mConfig.mServiceName.size();
            }
          else {
            desc48_set_service (newDesc, oldService, oldServiceLen);
            newDescLen += oldServiceLen;
            }

          desc_set_length (newDesc, newDescLen);
          totalDescLen += kDescHeaderSize + newDescLen;
          newDesc += kDescHeaderSize + newDescLen;
          }
        else {
          // Copy single descriptor
          int descLen = kDescHeaderSize + desc_get_length (desc);
          memcpy (newDesc, desc, descLen);
          newDesc += descLen;
          totalDescLen += descLen;
          }
        }
      sdtn_set_desclength (service, totalDescLen);
      }

    service = sdt_get_service (sdtSection, 1);
    if (service)
      sdt_set_length (sdtSection, service - sdtSection - SDT_HEADER_SIZE);
    else
      // This shouldn't happen if the incoming SDT is valid
      sdt_set_length (sdtSection, 0);

    psi_set_crc (output->mSdtSection);
    }
  //}}}

  //{{{
  void updatePAT (uint16_t sid) {

    for (auto output : mOutputs)
      if (output->mConfig.mSid == sid)
        newPAT (output);
    }
  //}}}
  //{{{
  void updatePMT (uint16_t sid) {

    for (auto output : mOutputs)
      if (output->mConfig.mSid == sid)
        newPMT (output);
    }
  //}}}
  //{{{
  void updateSDT (uint16_t sid) {

    for (auto output : mOutputs)
      if (output->mConfig.mSid == sid)
        newSDT (output);
    }
  //}}}
  //{{{
  void updateTsid() {

    uint16_t tsid = psi_table_get_tableidext (mCurrentPatSections);

    for (auto output : mOutputs)
      if (output->mConfig.mTsId == -1) {
        output->mTsId = tsid;
        newNIT (output);
        }
    }
  //}}}
  //{{{
  void markPmtPids (uint8_t* pmt, uint8_t pid_map[], uint8_t marker) {

    uint16_t pcrPid = pmt_get_pcrpid (pmt);
    if (pcrPid != kPaddingPid)
      pid_map[pcrPid] |= marker;

    uint16_t j = 0;
    uint8_t* es;
    while ((es = pmt_get_es (pmt, j))) {
      uint16_t pidNum = pmtn_get_pid (es);
      j++;

      if (pidWouldBeSelected (es))
        pid_map[pidNum] |= marker;

      mTsPids[pidNum].mPes = pidCarriesPES (es);
      }
    }
  //}}}

  //{{{
  bool isOurEpg (int tableId) {

    return (tableId == EIT_TABLE_ID_PF_ACTUAL) ||
           ((tableId >= EIT_TABLE_ID_SCHED_ACTUAL_FIRST) && (tableId <= EIT_TABLE_ID_SCHED_ACTUAL_LAST));
    }
  //}}}
  //}}}

  //  setup output
  //{{{
  struct addrinfo* parseHost (const char* hostStr, uint16_t defaultPort) {
  // !!! clean this up !!!

    char* ppsz_end = (char*)hostStr;
    char* strCopy = strdup (hostStr);

    char* psz_node;
    char* psz_end;
    int mFamily = AF_INET;
    if (strCopy[0] == '[') {
      //{{{  look for ipv6 address
      mFamily = AF_INET6;
      psz_node = strCopy + 1;
      psz_end = strchr( psz_node, ']');
      if (psz_end == NULL) {
        cLog::log (LOGERROR, "invalid IPv6 address %s", hostStr);
        free (strCopy);
        return NULL;
        }
      *psz_end++ = '\0';
      }
      //}}}
    else {
      psz_node = strCopy;
      psz_end = strpbrk (strCopy, "@:,/");
      }

    char* psz_port = NULL;
    if (psz_end != NULL && psz_end[0] == ':') {
      //{{{  look for port
      *psz_end++ = '\0';
      psz_port = psz_end;
      psz_end = strpbrk (psz_port, "@:,/");
      }
      //}}}

    if (psz_end != NULL) {
      *ppsz_end = '\0';
      if (ppsz_end != NULL)
        ppsz_end = (char*)hostStr + (psz_end - strCopy);
      }
    else if (ppsz_end != NULL)
      ppsz_end = (char*)hostStr + strlen (hostStr);

    char psz_port_buffer[6];
    if (defaultPort != 0 && (psz_port == NULL || !*psz_port)) {
      sprintf (psz_port_buffer, "%u", defaultPort);
      psz_port = psz_port_buffer;
      }

    if (psz_node[0] == '\0') {
      free (strCopy);
      return NULL;
      }

    struct addrinfo hint;
    memset (&hint, 0, sizeof(hint));
    hint.ai_family = mFamily;
    hint.ai_socktype = SOCK_DGRAM;
    hint.ai_protocol = 0;
    hint.ai_flags = AI_PASSIVE | AI_NUMERICHOST | AI_NUMERICSERV | AI_ADDRCONFIG;

    struct addrinfo* addr;
    int ret = getaddrinfo (psz_node, psz_port, NULL, &addr);
    if (ret) {
      cLog::log (LOGINFO, "getaddrinfo host:%s port:%s error:%s",
                 psz_node, psz_port ? psz_port : "", gai_strerror (ret));
      free (strCopy);
      return NULL;
      }

    free (strCopy);
    return addr;
    }
  //}}}
  //{{{
  cOutput* findOutput (const cOutputConfig& config) {

    socklen_t sockaddrLen = (config.mFamily == AF_INET) ? sizeof(struct sockaddr_in) : sizeof(struct sockaddr_in6);

    for (auto output : mOutputs) {
      if (config.mFamily != output->mConfig.mFamily ||
          memcmp (&config.mBindAddr, &output->mConfig.mBindAddr, sockaddrLen) ||
          memcmp (&config.mConnectAddr, &output->mConfig.mConnectAddr, sockaddrLen))
        continue;

      if ((config.mFamily == AF_INET6) && config.mIndexV6 != output->mConfig.mIndexV6)
        continue;

      return output;
      }

    return NULL;
    }
  //}}}
  //{{{
  cOutput* createOutput (const cOutputConfig* config) {

    auto output = new cOutput();
    if (output->initialise (config)) {
      mOutputs.push_back (output);
      return output;
      }

    delete output;
    return NULL;
    }
  //}}}
  //{{{
  void setOutput (cOutput* output, const cOutputConfig* config) {

    bool sidChanged = output->mConfig.mSid != config->mSid;
    bool dvbChanged = output->mConfig.mOutputDvb != config->mOutputDvb;
    bool epgChanged = output->mConfig.mOutputEpg != config->mOutputEpg;
    bool networkChanged = (output->mConfig.mNetworkId != config->mNetworkId) ||
                          (output->mConfig.mNetworkName != config->mNetworkName);
    bool mServiceChanged = output->mConfig.mServiceName != config->mServiceName;
    bool mProviderChanged = output->mConfig.mProviderName != config->mProviderName;

    output->mConfig.mOutputDvb = config->mOutputDvb;
    output->mConfig.mOutputEpg = config->mOutputEpg;
    output->mConfig.mNetworkId = config->mNetworkId;
    output->mConfig.mOnid = config->mOnid;

    output->mConfig.mNetworkName = config->mNetworkName;
    output->mConfig.mServiceName = config->mServiceName;
    output->mConfig.mProviderName = config->mProviderName;

    bool tsidChanged = false;
    if ((config->mTsId != -1) && (output->mConfig.mTsId != config->mTsId)) {
      output->mTsId = config->mTsId;
      output->mConfig.mTsId = config->mTsId;
      tsidChanged = true;
      }
    if ((config->mTsId == -1) && (output->mConfig.mTsId != -1)) {
      output->mConfig.mTsId = config->mTsId;
      if (psi_table_validate (mCurrentPatSections))
        output->mTsId = psi_table_get_tableidext (mCurrentPatSections);
      tsidChanged = true;
      }

    bool pidChanged = false;
    if (!(!sidChanged &&
         (config->mNumPids == output->mConfig.mNumPids) &&
         (!config->mNumPids || !memcmp (output->mConfig.mPids, config->mPids, config->mNumPids * sizeof(uint16_t))))) {
      //{{{  pids Changed
      uint16_t* wantedPids;
      int numWantedPids;
      uint16_t wantedPcrPid;
      uint16_t sidNum = config->mSid;
      uint16_t* pids = config->mPids;
      int numPids = config->mNumPids;
      getPids (&wantedPids, &numWantedPids, &wantedPcrPid, sidNum, pids, numPids);

      uint16_t* currentPids;
      int numCurrentPids;
      uint16_t currentPcrPid;
      uint16_t oldSidNum = output->mConfig.mSid;
      uint16_t* oldPids = output->mConfig.mPids;
      int oldNumPids = output->mConfig.mNumPids;
      getPids (&currentPids, &numCurrentPids, &currentPcrPid, oldSidNum, oldPids, oldNumPids);

      if (sidChanged && oldSidNum) {
        sSid* oldSid = findSid (oldSidNum);
        output->mConfig.mSid = config->mSid;
        if (oldSid)
          if (sidNum != oldSidNum)
            unselectPMT (oldSidNum, oldSid->mPmtPid);
        }

      for (int i = 0; i < numCurrentPids; i++) {
        if (!isIn (wantedPids, numWantedPids, currentPids[i])) {
          stopPid (output, currentPids[i]);
          pidChanged = true;
          }
        }

      for (int i = 0; i < numWantedPids; i++) {
        if (!isIn (currentPids, numCurrentPids, wantedPids[i])) {
          startPid (output, wantedPids[i]);
          pidChanged = true;
          }
        }

      free (wantedPids);
      free (currentPids);
      output->mPcrPid = wantedPcrPid;

      if (sidChanged && sidNum) {
        sSid* sid = findSid (sidNum);
        output->mConfig.mSid = oldSidNum;
        if (sid)
          if (sidNum != oldSidNum)
            selectPMT (sidNum, sid->mPmtPid);
        }

      output->mConfig.mSid = sidNum;
      free (output->mConfig.mPids);

      output->mConfig.mPids = (uint16_t*)malloc (sizeof(uint16_t) * numPids);
      memcpy (output->mConfig.mPids, pids, sizeof(uint16_t) * numPids);
      output->mConfig.mNumPids = numPids;
      }
      //}}}

    if (sidChanged || pidChanged || tsidChanged || dvbChanged || networkChanged || mServiceChanged || mProviderChanged)
      cLog::log (LOGINFO, format ("{} {}{}{}{}{}{}{}changed",
        output->mConfig.mDisplayName,
        dvbChanged ? "dvb " : "",
        sidChanged ? "sid " : "", pidChanged ? "pid " : "", tsidChanged ? "tsid " : "",
        networkChanged ? "network " : "", mServiceChanged ? "service " : "", mProviderChanged ? "provider " : ""));

    if (sidChanged || tsidChanged || dvbChanged)
      newPAT (output);
    if (sidChanged || pidChanged)
      newPMT (output);
    if (sidChanged || tsidChanged ||mServiceChanged || mProviderChanged || epgChanged)
      newSDT (output);
    if (sidChanged || tsidChanged || dvbChanged || networkChanged)
      newNIT (output);

    memcpy (output->mConfig.mSsrc, config->mSsrc, sizeof (config->mSsrc));

    int ret = 0;
    if (output->mConfig.mTtl != config->mTtl) {
      //{{{  new ttl
      if (output->mConfig.mFamily == AF_INET6) {
        struct sockaddr_in6* p_addr = (struct sockaddr_in6 *)&output->mConfig.mConnectAddr;
        if (IN6_IS_ADDR_MULTICAST(&p_addr->sin6_addr))
          ret = setsockopt (output->mSocket, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
                            (void*)&config->mTtl, sizeof(config->mTtl));
        }
      else {
        struct sockaddr_in* p_addr = (struct sockaddr_in*)&output->mConfig.mConnectAddr;
        if (IN_MULTICAST(ntohl (p_addr->sin_addr.s_addr)))
          ret = setsockopt (output->mSocket, IPPROTO_IP, IP_MULTICAST_TTL,
                            (void*)&config->mTtl, sizeof(config->mTtl));
        }

      output->mConfig.mTtl = config->mTtl;
      }
      //}}}
    if (output->mConfig.mTos != config->mTos) {
      //{{{  new tos
      if (output->mConfig.mFamily == AF_INET)
        ret = setsockopt (output->mSocket, IPPROTO_IP, IP_TOS, (void*)&config->mTos, sizeof(config->mTos));

      output->mConfig.mTos = config->mTos;
      }
      //}}}
    if (ret == -1)
      cLog::log (LOGERROR, "socket change failed %s", strerror(errno));

    if (output->mConfig.mMtu != config->mMtu) {
      //{{{  new mtu
      sRtpPacket* packet = output->mLastPacket;
      output->mConfig.mMtu = config->mMtu;

      output->packetCleanup();
      int blockCount = output->getBlockCount();
      if (packet && (packet->mDepth < blockCount)) {
        packet = (sRtpPacket*)realloc (packet, sizeof(sRtpPacket*) + blockCount * sizeof(cTsBlock*));
        output->mLastPacket = packet;
        }
      }
      //}}}
    }
  //}}}

  // send output
  //{{{
  void outputPut (cOutput* output, cTsBlock* block) {
  // assemble ts block into tcp packets, not sure why there is more than one packet for each output, timestamp?

    block->incRefCount();
    int blockCount = output->getBlockCount();

    if (output->mLastPacket && (output->mLastPacket->mDepth < blockCount)) {
      // add tsBlock to partial rtp packet
      sRtpPacket* packet = output->mLastPacket;
      if (ts_has_adaptation (block->mTs) && ts_get_adaptation (block->mTs) && tsaf_has_pcr (block->mTs))
        packet->mDts = block->mDts;

      packet->mBlocks[packet->mDepth] = block;
      packet->mDepth++;

      if (packet->mDepth == blockCount) {
        // send packet
        packet = output->mPackets;

        //{{{  form rtp packet iovecs
        // udp rtp header layout
        //  0                   1                   2                   3
        //  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        // +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        // |V=2|P|X|  CC   |M|     PT      |       sequence number         |
        // +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        // |                           timestamp                           |
        // +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        // |           synchronization source (SSRC) identifier            |
        // +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
        // |            contributing source (CSRC) identifiers             |
        // |                             ....                              |
        // +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

        struct iovec iovecs[blockCount + 2];
        uint8_t rtpHeader[kRtpHeaderSize];

        iovecs[0].iov_base = rtpHeader;
        iovecs[0].iov_len = kRtpHeaderSize;

        // set rtpHeader
        rtpHeader[0] = 0x80;
        rtpHeader[1] = 33; // RTP_TYPE_TS & 0x7f;
        rtpHeader[2] = output->mSeqnum >> 8;
        rtpHeader[3] = output->mSeqnum & 0xff;
        output->mSeqnum++;

        // timestamp based only on local time when sent 90 kHz clock = 90000 counts per second
        uint32_t timestamp = mdate() * 9/100;
        rtpHeader[4] = (timestamp >> 24) & 0xff;
        rtpHeader[5] = (timestamp >> 16) & 0xff;
        rtpHeader[6] = (timestamp >> 8) & 0xff;
        rtpHeader[7] = timestamp & 0xff;

        // set ssrc
        rtpHeader[8] = output->mConfig.mSsrc[0];
        rtpHeader[9] = output->mConfig.mSsrc[1];
        rtpHeader[10] = output->mConfig.mSsrc[2];
        rtpHeader[11] = output->mConfig.mSsrc[3];

        // rtp body
        int numIov = 1;

        int blockNum;
        for (blockNum = 0; blockNum < packet->mDepth; blockNum++) {
          iovecs[numIov].iov_base = packet->mBlocks[blockNum]->mTs;
          iovecs[numIov].iov_len = kTsSize;
          numIov++;
          }

        // rtp padding
        for (; blockNum < blockCount; blockNum++) {
          iovecs[numIov].iov_base = kPadTs;
          iovecs[numIov].iov_len = kTsSize;
          numIov++;
          }
        //}}}

        // send rtp packet iovecs
        if (writev (output->mSocket, iovecs, numIov) < 0)
          cLog::log (LOGERROR, "outputPut writev failed " + output->mConfig.mDisplayName);

        // release packets
        for (blockNum = 0; blockNum < packet->mDepth; blockNum++)
          mBlockPool->unRefBlock (packet->mBlocks[blockNum]);

        output->mPackets = packet->mNextPacket;
        output->packetDelete (packet);
        if (output->mPackets == NULL)
          output->mLastPacket = NULL;
        }
      }

    else {
      // start new rtp packet
      sRtpPacket* packet = output->packetNew();
      packet->mDts = block->mDts;
      if (output->mLastPacket)
        output->mLastPacket->mNextPacket = packet;
      else
        output->mPackets = packet;

      // add packet to packetList
      output->mLastPacket = packet;
      packet->mBlocks[packet->mDepth] = block;
      packet->mDepth++;
      }
    }
  //}}}
  //{{{
  void outputPsiSection (cOutput* output, uint8_t* section, uint16_t pidNum, uint8_t& continuity, int64_t dts) {
  // output simple psi section

    cTsBlock* block = mBlockPool->newBlock();
    block->mDts = dts;

    uint8_t* p = block->mTs;
    uint8_t tsOffset = 0;
    uint16_t sectionOffset = 0;
    psi_split_section (p, tsOffset, section, sectionOffset);

    ts_set_pid (p, pidNum);
    ts_set_cc (p, continuity);
    continuity = (continuity + 1) & 0xf;
    psi_split_end (p, tsOffset);

    block->decRefCount();
    outputPut (output, block);
    }
  //}}}
  //{{{
  void sendBlock (cTsBlock* block) {

    for (auto output : mOutputs)
      if (output->mConfig.mOutputDvb && output->mSdtSection)
        outputPut (output, block);
    }
  //}}}
  //{{{
  void sendPAT (int64_t dts) {

    for (auto output : mOutputs) {
      if (!output->mPatSection && psi_table_validate (mCurrentPatSections)) {
        // SID doesn't exist - build an empty PAT
        uint8_t* patSection = psi_allocate();
        output->mPatSection = patSection;
        output->mPatVersion++;

        pat_init (patSection);
        pat_set_length (patSection, 0);
        pat_set_tsid (patSection, output->mTsId);
        psi_set_version (patSection, output->mPatVersion);
        psi_set_current (patSection);
        psi_set_section (patSection, 0);
        psi_set_lastsection (patSection, 0);
        psi_set_crc (output->mPatSection);
        }

      if (output->mPatSection)
        outputPsiSection (output, output->mPatSection, kPatPid, output->mPatContinuity, dts);
      }
    }
  //}}}
  //{{{
  void parsePMT (cOutput* output, uint8_t* section) {
  // parse pmtSection for streams

    //int tid = section[0];
    int sectionLength = cDvbUtils::getSectionLength (section+1);

    //int sid = (section[3] << 8) + section[4];
    int programInfoLength = ((section[10] & 0x0f) << 8) + section[11];

    // skip past pmt header
    constexpr int kPmtHeaderLength = 12;
    section += kPmtHeaderLength + programInfoLength;
    sectionLength -= kPmtHeaderLength + 4 - programInfoLength;

    // iterate pmt streams
    while (sectionLength > 0) {
      int streamType = section[0];
      int streamPid = ((section[1] & 0x1F) << 8) + section[2];
      int streamInfoLength = ((section[3] & 0x0F) << 8) + section[4];

      //cLog::log (LOGINFO, format ("stream sid {} {} {}", sid, streamType, streamPid));
      switch (streamType) {
        case  2: // ISO 13818-2 video
        case 27: // h264video
          output->mVidPid = streamPid;
          break;

        case  3: // ISO 11172-3 audio
        case 17: // aacLatm
          output->mAudPid = streamPid;
          break;

        case  6: // subtitle
          output->mSubPid = streamPid;
          break;

        default:
          break;
        }

      constexpr int kPmtStreamLength = 5;
      section += kPmtStreamLength + streamInfoLength;
      sectionLength -= kPmtStreamLength + streamInfoLength;
      }
    }
  //}}}
  //{{{
  void sendPMT (sSid* sid, int64_t dts) {

    int pmtPid = sid->mPmtPid;

    for (auto output: mOutputs)
      if ((output->mConfig.mSid == sid->mSid) && output->mPmtSection) {
        parsePMT (output, output->mPmtSection);
        outputPsiSection (output, output->mPmtSection, pmtPid, output->mPmtContinuity, dts);
        }
    }
  //}}}
  //{{{
  void sendNIT (int64_t dts) {

    for (auto output: mOutputs)
      if (output->mConfig.mOutputDvb && output->mNitSection)
        outputPsiSection (output, output->mNitSection, kNitPid, output->mNitContinuity, dts);
    }
  //}}}
  //{{{
  void parseSDT (cOutput* output, uint8_t* section) {
  // parse sdtSection for serviceName

    int tid = section[0];
    if (tid == 0x42) {
      int sectionLength = cDvbUtils::getSectionLength (section+1);

      // skip past sdt header
      constexpr int kSdtHeaderLength = 11;
      section += kSdtHeaderLength;
      sectionLength -= kSdtHeaderLength + 4;

      // iterate sdt sections
      while (sectionLength > 0) {
        // sdt descriptor
        int loopLength = ((section[3] & 0x0F) << 8) + section[4];

        // skip past sdt descriptor
        constexpr int kSdtDescriptorLength = 5;
        section += kSdtDescriptorLength;
        sectionLength -= kSdtDescriptorLength;

        // iterate descriptors
        int i = 0;
        int descrLength = section[1] + 2;
        while ((i < loopLength) && (descrLength > 0) && (descrLength <= loopLength - i)) {
          if (section[0] == 0x48) // serviceDescriptor
            output->mNameString = cDvbUtils::getString (section+4);
          i += descrLength;
          section += descrLength;
          descrLength = section[1] + 2;
          }
        sectionLength -= loopLength;
        }
      }
    }
  //}}}
  //{{{
  void sendSDT (int64_t dts) {

    for (auto output : mOutputs)
      if (output->mConfig.mOutputDvb && output->mSdtSection) {
        parseSDT (output, output->mSdtSection);
        outputPsiSection (output, output->mSdtSection, kSdtPid, output->mSdtContinuity, dts);
        }
    }
  //}}}
  //{{{
  void parseEIT (cOutput* output, uint8_t* section) {
  // parse eitSection for shortEvent now program name, startTime

    int tid = section[0];
    int sectionLength = cDvbUtils::getSectionLength (section+1);

    // skip past eit header to first eitEvent
    constexpr int kEitHeaderLength = 14;
    section += kEitHeaderLength;
    sectionLength -= kEitHeaderLength + 4;

    // iterate eit events
    while (sectionLength > 0) {
      system_clock::time_point startTime =
        system_clock::from_time_t (cDvbUtils::getEpochTime (section+2) + cDvbUtils::getBcdTime (section+4));
      seconds duration (cDvbUtils::getBcdTime (section+7));
      int running = (section[10] & 0xE0) >> 5;
      int loopLength = ((section[10] & 0x0F) << 8) + section[11];

      // skip past eitEvent
      constexpr int kEitEventLength = 12;
      section += kEitEventLength;
      sectionLength -= kEitEventLength;

      // iterate eit event descriptors
      int i = 0;
      int descrLength = section[1] + 2;
      while ((i < loopLength) && (descrLength > 0) && (descrLength <= loopLength - i)) {
        // 0x4E: extendedEvent, could use ??
        if (section[0] == 0x4D) {
          // shortEvent
          //bool epg = (tid == 0x50) || (tid == 0x51);
          bool now = (tid == 0x4E) && (running == 0x04);
          if (now)
            output->mNowString = format ("{} {:3}m {}",
                                         date::format ("%H:%M", floor<seconds>(startTime)), duration.count()/60,
                                         cDvbUtils::getString (section+5));
          }

        i += descrLength;
        section += descrLength;
        descrLength = section[1] + 2;
        }

      sectionLength -= loopLength;
      }
    }
  //}}}
  //{{{
  void outputEIT (cOutput* output, uint8_t* section, uint16_t pidNum, uint8_t& continuity, int64_t dts,
                  cTsBlock*& tsBuffer, uint8_t& tsBufferOffset) {

    uint16_t sectionOffset = 0;
    uint16_t sectionLength = psi_get_length (section) + kPsiHeaderSize;

    do {
      cTsBlock* block;
      uint8_t tsOffset;

      if (tsBuffer) {
        block = tsBuffer;
        tsOffset = tsBufferOffset;
        }
      else {
        block = mBlockPool->newBlock();
        block->mDts = dts;
        tsOffset = 0;
        }
      uint8_t* p = block->mTs;

      psi_split_section (p, tsOffset, section, sectionOffset);

      if (!tsBuffer) {
        ts_set_pid (p, pidNum);
        ts_set_cc (p, continuity);
        continuity = (continuity + 1) & 0xf;
        }

      if (sectionOffset == sectionLength) {
        if (tsOffset < kTsSize - MIN_SECTION_FRAGMENT && tsBuffer) {
          tsBuffer = block;
          tsBufferOffset = tsOffset;
          break;
          }
        else
          psi_split_end (p, tsOffset);
        }

      block->mDts = dts;
      block->decRefCount();
      outputPut (output, block);

      tsBuffer = NULL;
      tsBufferOffset = 0;
      } while (sectionOffset < sectionLength);
    }
  //}}}
  //{{{
  void sendEIT (sSid* sid, int64_t dts, uint8_t* eit) {

    uint16_t onid = eit_get_onid (eit);

    for (auto output : mOutputs)
      if (output->mConfig.mOutputDvb &&
          (!isOurEpg (psi_get_tableid (eit)) || output->mConfig.mOutputEpg) &&
          (output->mConfig.mSid == sid->mSid)) {

        // set eit section
        eit_set_tsid (eit, output->mTsId);
        eit_set_sid (eit, output->mConfig.mSid);
        if (output->mConfig.mOnid)
          eit_set_onid (eit, output->mConfig.mOnid);
        psi_set_crc (eit);

        output->nEitSectionsCount++;
        parseEIT (output, eit);
        outputEIT (output, eit, kEitPid, output->mEitContinuity, dts,
                   output->mEitTsBuffer, output->mEitTsBufferOffset);

        if (output->mConfig.mOnid)
          eit_set_onid (eit, onid);
        }
    }
  //}}}
  //{{{
  void flushEIT (cOutput* output, int64_t dts) {

    cTsBlock* block = output->mEitTsBuffer;
    psi_split_end (block->mTs, output->mEitTsBufferOffset);

    block->mDts = dts;
    block->decRefCount();
    outputPut (output, block);

    output->mEitTsBuffer = NULL;
    output->mEitTsBufferOffset = 0;
    }
  //}}}

  // demux
  //{{{
  void deleteProgram (uint16_t sidNum, uint16_t pidNum) {

    unselectPMT (sidNum, pidNum);

    sSid* sid = findSid (sidNum);
    if (sid == NULL)
      return;

    uint8_t* pmt = sid->mCurrentPmt;
    if (pmt) {
      uint16_t pcrPid = pmt_get_pcrpid (pmt);
      if (pcrPid != kPaddingPid && pcrPid != sid->mPmtPid)
        unselectPid (sidNum, pcrPid);

      uint8_t j = 0;
      uint8_t* es;
      while ((es = pmt_get_es (pmt, j))) {
        uint16_t esPid = pmtn_get_pid (es);
        j++;
        if (pidWouldBeSelected (es))
          unselectPid (sidNum, esPid);
        }

      free (pmt);
      sid->mCurrentPmt = NULL;
      }

    sid->mSid = 0;
    sid->mPmtPid = 0;
    for (uint8_t table = 0; table < MAX_EIT_TABLES; table++) {
      psi_table_free (sid->mEitTables[table].data);
      psi_table_init (sid->mEitTables[table].data);
      }
    }
  //}}}
  //{{{
  void handlePAT (int64_t dts) {

    bool change = false;
    uint8_t* oldPatSections[kPsiTableMaxSections];
    uint8_t lastSection = psi_table_get_lastsection (mNextPatSections);

    if (psi_table_validate (mCurrentPatSections) && psi_table_compare (mCurrentPatSections, mNextPatSections)) {
      // identical PAT
      psi_table_free (mNextPatSections);
      psi_table_init (mNextPatSections);
      sendPAT (dts);
      return;
      }

    if (!pat_table_validate (mNextPatSections)) {
      //{{{  invalid PAT error return
      cLog::log (LOGERROR, "invalid PAT received");
      psi_table_free (mNextPatSections);
      psi_table_init (mNextPatSections);
      sendPAT (dts);
      return;
      }
      //}}}

    // Switch tables
    psi_table_copy (oldPatSections, mCurrentPatSections);
    psi_table_copy (mCurrentPatSections, mNextPatSections);
    psi_table_init (mNextPatSections);

    if (!psi_table_validate (oldPatSections) ||
        (psi_table_get_tableidext (mCurrentPatSections) != psi_table_get_tableidext (oldPatSections))) {
      // trigger universal reset of everything
      change = true;
      updateTsid();
      }

    for (int i = 0; i <= lastSection; i++) {
      int j = 0;
      uint8_t* section = psi_table_get_section (mCurrentPatSections, i);
      const uint8_t* program;
      while ((program = pat_get_program (section, j))) {
        const uint8_t* oldProgram = NULL;
        uint16_t sid = patn_get_program (program);
        uint16_t pid = patn_get_pid (program);
        j++;

        if (sid == 0) {
          if (pid != kNitPid)
            cLog::log (LOGINFO, "nit is carried on PID %d which isn't DVB compliant", pid);
          continue; // NIT
          }

          if (!psi_table_validate (oldPatSections) ||
              ((oldProgram = pat_table_find_program (oldPatSections, sid)) == NULL) ||
              patn_get_pid (oldProgram) != pid ||
              change) {
            sSid* p_sid;

          if (oldProgram)
            deleteProgram (sid, patn_get_pid (oldProgram));

          selectPMT (sid, pid);

          p_sid = findSid (0);
          if (p_sid == NULL) {
            // not found, create and add new sid
            p_sid = (sSid*)malloc (sizeof(sSid));
            p_sid->mCurrentPmt = NULL;
            for (int table = 0; table < MAX_EIT_TABLES; table++)
              psi_table_init (p_sid->mEitTables[table].data);

            mNumSids++;
            mSids = (sSid**)realloc (mSids, sizeof(sSid*) * mNumSids);
            mSids[mNumSids - 1] = p_sid;
            }

          p_sid->mSid = sid;
          p_sid->mPmtPid = pid;
          updatePAT (sid);
          }
        }
      }

    if (psi_table_validate (oldPatSections)) {
      lastSection = psi_table_get_lastsection (oldPatSections);
      for (int i = 0; i <= lastSection; i++) {
        uint8_t* section = psi_table_get_section (oldPatSections, i);
        const uint8_t* program;
        int j = 0;
        while ((program = pat_get_program (section, j))) {
          uint16_t sid = patn_get_program (program);
          uint16_t pid = patn_get_pid (program);
          j++;

          if (sid == 0)
            continue; // NIT met

          if (pat_table_find_program (mCurrentPatSections, sid) == NULL) {
            deleteProgram (sid, pid);
            updatePAT (sid);
            }
          }
        }

      psi_table_free (oldPatSections);
      }

    sendPAT (dts);
    }
  //}}}
  //{{{
  void handlePATSection (uint16_t pid, uint8_t* section, int64_t dts) {

    if ((pid != kPatPid) || !pat_validate (section)) {
      cLog::log (LOGERROR, "invalid pat section pid:%d", pid);
      free (section);
      return;
      }

    if (!psi_table_section (mNextPatSections, section))
      return;

    handlePAT (dts);
    }
  //}}}
  //{{{
  void handlePMT (uint16_t pid, uint8_t* pmt, int64_t dts) {

    uint16_t sidNum = pmt_get_program (pmt);
    sSid* sid = findSid (sidNum);
    if (sid == NULL) {
      //{{{  unwanted SID error return
      free (pmt);
      return;
      }
      //}}}

    if (pid != sid->mPmtPid) {
      //{{{  invalid pmt section error return
      cLog::log (LOGERROR, "invalid pmt section pid:%d", pid);
      free (pmt);
      return;
      }
      //}}}

    if (sid->mCurrentPmt && psi_compare (sid->mCurrentPmt, pmt)) {
      // identical PMT
      free (pmt);
      sendPMT (sid, dts);
      return;
      }

    if  (!pmt_validate (pmt)) {
      //{{{  invalid pmt section return
      cLog::log (LOGERROR, "invalid pmt section pid:%d", pid);
      free (pmt);

      sendPMT (sid, dts);
      return;
      }
      //}}}

    uint8_t pid_map[kMaxPids];
    memset (pid_map, 0, sizeof(pid_map));

    if (sid->mCurrentPmt) {
      markPmtPids (sid->mCurrentPmt, pid_map, 0x02);
      free (sid->mCurrentPmt);
      }

    markPmtPids (pmt, pid_map, 0x01);

    uint16_t pcrPid = pmt_get_pcrpid (pmt);
    for (auto output : mOutputs)
      if (output->mConfig.mSid == sidNum)
        output->mPcrPid = 0;

    // start to stream PIDs
    for (int pid = 0; pid < kMaxPids; pid++) {
      // pid does not exist in the old PMT and in the new PMT. Ignore this pid.
      if (!pid_map[pid])
        continue;

      switch (pid_map[pid] & 0x03) {
        case 0x03: // The pid exists in the old PMT and in the new PMT. The pid was already selected in case 0x01.
          continue;

        case 0x02: // The pid does not exist in the new PMT but exists in the old PMT. Unselect it
          unselectPid (sidNum, pid);
          break;

        case 0x01: // The pid exists in new PMT. Select it
          selectPid (sidNum, pid, pid == pcrPid);
          break;
        }
      }

    sid->mCurrentPmt = pmt;
    updatePMT (sidNum);
    sendPMT (sid, dts);
    }
  //}}}
  //{{{
  void handleNIT (int64_t dts) {

    if (psi_table_validate (mCurrentNitSections) &&
        psi_table_compare (mCurrentNitSections, mNexttNitSections)) {
      // identical NIT
      psi_table_free (mNexttNitSections);
      psi_table_init (mNexttNitSections);
      return;
      }

    if (!nit_table_validate (mNexttNitSections)) {
      //{{{  invalid nit error, return
      cLog::log (LOGERROR, "invalid NIT received");
      psi_table_free (mNexttNitSections);
      psi_table_init (mNexttNitSections);
      return;
      }
      //}}}

    // switch tables
    psi_table_free (mCurrentNitSections);
    psi_table_copy (mCurrentNitSections, mNexttNitSections);
    psi_table_init (mNexttNitSections);
    }
  //}}}
  //{{{
  void handleNITSection (uint16_t pid, uint8_t* section, int64_t dts) {

    if (pid != kNitPid || !nit_validate (section)) {
      cLog::log (LOGERROR, "invalid nit section pid:%d", pid);
      free (section);
      return;
      }

    if (psi_table_section (mNexttNitSections, section))
      handleNIT (dts);

    // This case is different because DVB specifies a minimum bitrate for PID 0x10
    // even if we don't have any thing to send (for cheap transport over network boundaries)
    sendNIT (dts);
    }
  //}}}
  //{{{
  void handleSDT (int64_t dts) {

    uint8_t* oldSdtSections[kPsiTableMaxSections];
    uint8_t lastSection = psi_table_get_lastsection (mNextSdtSections);

    if (psi_table_validate (mCurrentSdtSections) && psi_table_compare (mCurrentSdtSections, mNextSdtSections)) {
      // identical SDT
      psi_table_free (mNextSdtSections);
      psi_table_init (mNextSdtSections);
      sendSDT (dts);
      return;
      }

    if (!sdt_table_validate (mNextSdtSections)) {
      //{{{  invalid sdt, return
      cLog::log (LOGERROR, "invalid sdt received");
      psi_table_free (mNextSdtSections);
      psi_table_init (mNextSdtSections);
      sendSDT (dts);
      return;
      }
      //}}}

    // switch tables
    psi_table_copy (oldSdtSections, mCurrentSdtSections);
    psi_table_copy (mCurrentSdtSections, mNextSdtSections);
    psi_table_init (mNextSdtSections);

    int j;
    for (int i = 0; i <= lastSection; i++) {
      uint8_t* section = psi_table_get_section (mCurrentSdtSections, i);
      j = 0;
      uint8_t* service;
      while ((service = sdt_get_service (section, j))) {
        uint16_t sid = sdtn_get_sid (service);
        j++;
        updateSDT (sid);
        }
      }

    if (psi_table_validate (oldSdtSections)) {
      lastSection = psi_table_get_lastsection (oldSdtSections);
      for (int i = 0; i <= lastSection; i++) {
        uint8_t* section = psi_table_get_section (oldSdtSections, i);
        int j = 0;
        const uint8_t* service;
        while ((service = sdt_get_service (section, j))) {
          uint16_t sid = sdtn_get_sid (service);
          j++;
          if (sdt_table_find_service (mCurrentSdtSections, sid) == NULL)
            updateSDT (sid);
          }
        }

      psi_table_free (oldSdtSections);
      }

    sendSDT (dts);
    }
  //}}}
  //{{{
  void handleSDTSection (uint16_t pid, uint8_t* section, int64_t dts) {

    if ((pid != kSdtPid) || !sdt_validate (section)) {
      //{{{  invalid sdt section, return
      cLog::log (LOGERROR, "invalid SDT section pid:%d", pid);
      free (section);
      return;
      }
      //}}}

    if (!psi_table_section (mNextSdtSections, section))
      return;

    handleSDT (dts);
    }
  //}}}
  //{{{
  void handleEIT (uint16_t pid, uint8_t* eit, int64_t dts) {

    uint8_t tableId = psi_get_tableid (eit);
    uint16_t sidNum = eit_get_sid (eit);

    sSid* sid = findSid (sidNum);
    if (!sid) {
      // Not a selected program
      free (eit);
      return;
      }

    if ((pid != kEitPid) || !eit_validate (eit)) {
      //{{{  invalid eit section, return
      cLog::log (LOGERROR, "invalid eit section pid:%d", pid);
      free (eit);
      return;
      }
      //}}}

    if (!isOurEpg (tableId)) {
      sendEIT (sid, dts, eit);
      free (eit);
      return;
      }

    // We do not use psi_table_* primitives as the spec allows for holes in
    // section numbering, and there is no sure way to know whether you have gathered all sections
    uint8_t iSection = psi_get_section (eit);
    uint8_t eitTableId = tableId - EIT_TABLE_ID_PF_ACTUAL;
    if (eitTableId >= MAX_EIT_TABLES) {
      sendEIT (sid, dts, eit);
      return;
      }

    if (sid->mEitTables[eitTableId].data[iSection] &&
        psi_compare (sid->mEitTables[eitTableId].data[iSection], eit)) {
      // identical section
      free (sid->mEitTables[eitTableId].data[iSection]);
      sid->mEitTables[eitTableId].data[iSection] = eit;
      sendEIT (sid, dts, eit);
      return;
      }

    free (sid->mEitTables[eitTableId].data[iSection]);
    sid->mEitTables[eitTableId].data[iSection] = eit;
    sendEIT (sid, dts, eit);
    }
  //}}}
  //{{{
  void handleRST (cTsBlock* block) {

    sendBlock (block);
    }
  //}}}
  //{{{
  void handleTDT (cTsBlock* block) {
  // dumb parser, loadsa of assumptions, no crc

    uint8_t* ts = block->mTs;

    // skip to tableId
    ts += 5;
    if (ts[0] == TDT_TABLE_ID) {
      uint32_t epochTime = (((ts[3] << 8) | ts[4]) - 40587) * 86400;
      uint32_t time = (3600 * ((10 * ((ts[5] & 0xF0) >> 4)) + (ts[5] & 0xF))) +
                        (60 * ((10 * ((ts[6] & 0xF0) >> 4)) + (ts[6] & 0xF))) +
                              ((10 * ((ts[7] & 0xF0) >> 4)) + (ts[7] & 0xF));

      mTime = system_clock::from_time_t (epochTime + time);
      mTimeString = date::format ("%T", date::floor<seconds>(mTime));
      }

    sendBlock (block);
    }
  //}}}
  //{{{
  void handleSection (uint16_t pid, uint8_t* section, int64_t dts) {

    if (!psi_validate (section)) {
      //{{{  invalid section error, return
      cLog::log (LOGERROR, "invalid section pid:%d", pid);
      free (section);
      return;
      }
      //}}}

    if (!psi_get_current (section)) {
      // ignore sections which are not in use yet
      free (section);
      return;
      }

    uint8_t tableId = psi_get_tableid (section);
    switch (tableId) {
      case PAT_TABLE_ID:
        handlePATSection (pid, section, dts);
        break;

      case PMT_TABLE_ID:
        handlePMT (pid, section, dts);
        break;

      case NIT_TABLE_ID_ACTUAL:
        handleNITSection (pid, section, dts);
        break;

      case SDT_TABLE_ID_ACTUAL:
        handleSDTSection (pid, section, dts);
        break;

      default:
        if (isOurEpg (tableId)) {
          handleEIT (pid, section, dts);
          break;
          }
        free (section);
        break;
      }
    }
  //}}}
  //{{{
  void handlePsiPacket (uint8_t* ts, int64_t dts) {

    uint16_t pid = ts_get_pid (ts);
    sTsPid* tsPid = &mTsPids[pid];

    uint8_t continuity = ts_get_cc (ts);
    if (ts_check_duplicate (continuity, tsPid->mLastContinuity) || !ts_has_payload (ts))
      return;

    if ((tsPid->mLastContinuity != -1) &&
        ts_check_discontinuity (continuity, tsPid->mLastContinuity))
      psi_assemble_reset (&tsPid->mPsiBuffer, &tsPid->mPsiBufferUsed);

    const uint8_t* payload = ts_section (ts);
    uint8_t length = ts + kTsSize - payload;
    if (!psi_assemble_empty (&tsPid->mPsiBuffer, &tsPid->mPsiBufferUsed)) {
      uint8_t* section = psi_assemble_payload (&tsPid->mPsiBuffer, &tsPid->mPsiBufferUsed, &payload, &length);
      if (section)
        handleSection (pid, section, dts);
      }

    payload = ts_next_section (ts);
    length = ts + kTsSize - payload;
    while (length) {
      uint8_t* section = psi_assemble_payload (&tsPid->mPsiBuffer, &tsPid->mPsiBufferUsed, &payload, &length);
      if (section)
        handleSection (pid, section, dts);
      }
    }
  //}}}
  //{{{
  void demuxBlock (cTsBlock* block) {
  // demux single ts block

    uint16_t pidNum = ts_get_pid (block->mTs);
    sTsPid* tsPid = &mTsPids[pidNum];
    uint8_t continuity = ts_get_cc (block->mTs);

    mNumPackets++;
    if (!ts_validate (block->mTs)) {
      //{{{  error return
      cLog::log (LOGERROR, "lost TS sync");
      mBlockPool->freeBlock (block);
      mNumInvalids++;
      return;
      }
      //}}}

    if ((pidNum != kPaddingPid) &&
        (tsPid->mLastContinuity != -1) &&
        !ts_check_duplicate (continuity, tsPid->mLastContinuity) &&
        ts_check_discontinuity (continuity, tsPid->mLastContinuity)) {
      //{{{  continutiy error
      mNumDiscontinuities++;
      uint16_t sid;
      string pidDesc = getPidDesc (pidNum, sid);
      cLog::log (LOGERROR, format ("continuity sid:{} pid:{} {}:{} {}",
                                   sid, pidNum, continuity, (tsPid->mLastContinuity+1) & 0x0f, pidDesc));
      }
      //}}}

    if (ts_get_transporterror (block->mTs)) {
      //{{{  tuner error
      mNumErrors++;
      mTunerErrors++;
      uint16_t sid;
      string desc = getPidDesc (pidNum, sid);
      cLog::log (LOGERROR, format ("transportErorIndicator pid:{} {} sid:{}", pidNum, desc, sid));

      if (mTunerErrors > kMaxTunerErrorsTillReset) {
        mTunerErrors = 0;
        mDvb->reset();
        }
      }
      //}}}
    else if (pidNum == kRstPid)
      handleRST (block);
    else if (pidNum == kTdtPid)
      handleTDT (block);
    else if (tsPid->mPsiRefCount)
      handlePsiPacket (block->mTs, block->mDts);
    tsPid->mLastContinuity = continuity;

    // output
    for (int i = 0; i < tsPid->mNumOutputs; i++) {
      cOutput* output = tsPid->mOutputs[i];
      // ??? no sure what this does ???
      if ((output->mPcrPid != pidNum) ||
          (ts_has_adaptation (block->mTs) && ts_get_adaptation (block->mTs) && tsaf_has_pcr (block->mTs)))
        outputPut (output, block);

      // send out EIT if retained for more than kMaxEitRetentionMicroSeconds - 500ms
      if (output->mEitTsBuffer &&
          (block->mDts > output->mEitTsBuffer->mDts + kMaxEitRetentionMicroSeconds))
        flushEIT (output, block->mDts);
      }

    mBlockPool->unRefBlock (block);
    }
  //}}}

  // close output
  //{{{
  void outputClose (cOutput* output) {

    sRtpPacket* packet = output->mPackets;
    while (packet) {
      for (int i = 0; i < packet->mDepth; i++)
        mBlockPool->unRefBlock (packet->mBlocks[i]);
      output->mPackets = packet->mNextPacket;
      output->packetDelete (packet);
      packet = output->mPackets;
      }
    output->packetCleanup();

    output->mPackets = output->mLastPacket = NULL;
    free (output->mPatSection);
    free (output->mPmtSection);
    free (output->mNitSection);
    free (output->mSdtSection);
    free (output->mEitTsBuffer);

    close (output->mSocket);

    free (output->mConfig.mPids);
    }
  //}}}
  }

// cDvbRtp
//{{{
cDvbRtp::cDvbRtp (cDvb* dvb, cTsBlockPool* blockPool) {

  mDvb = dvb;
  mBlockPool= blockPool;

  memset (mTsPids, 0, sizeof(mTsPids));
  for (int i = 0; i < kMaxPids; i++) {
    mTsPids[i].mLastContinuity = -1;
    mTsPids[i].mDemuxFd = -1;
    psi_assemble_init (&mTsPids[i].mPsiBuffer, &mTsPids[i].mPsiBufferUsed);
    }

  if (mBudgetMode)
    mBudgetDemuxFd = mDvb->setFilter (8192);

  psi_table_init (mCurrentPatSections);
  psi_table_init (mNextPatSections);

  setPid (kPatPid);
  mTsPids[kPatPid].mPsiRefCount++;

  setPid (kNitPid);
  mTsPids[kNitPid].mPsiRefCount++;

  psi_table_init (mCurrentSdtSections);
  psi_table_init (mNextSdtSections);

  setPid (kSdtPid);
  mTsPids[kSdtPid].mPsiRefCount++;

  setPid (kEitPid);
  mTsPids[kEitPid].mPsiRefCount++;

  setPid (kRstPid);
  setPid (kTdtPid);
  }
//}}}
//{{{
cDvbRtp::~cDvbRtp() {

  // close tables
  psi_table_free (mCurrentPatSections);
  psi_table_free (mNextPatSections);
  psi_table_free (mCurrentNitSections);
  psi_table_free (mNexttNitSections);
  psi_table_free (mCurrentSdtSections);
  psi_table_free (mNextSdtSections);

  // close pids
  for (int pid = 0; pid < kMaxPids; pid++) {
    free (mTsPids[pid].mPsiBuffer);
    free (mTsPids[pid].mOutputs);
    }

  // close sids
  for (int i = 0; i < mNumSids; i++) {
    sSid* sid = mSids[i];
    for (int table = 0; table < MAX_EIT_TABLES; table++)
      psi_table_free (sid->mEitTables[table].data);
    free (sid->mCurrentPmt);
    free (sid);
    }
  free (mSids);

  // close outputs
  for (auto output : mOutputs) {
    cLog::log (LOGINFO, "remove "+ output->mConfig.mDisplayName);
    outputClose (output);
    delete output;
    }

  mOutputs.clear();
  }
//}}}
//{{{  gets
uint64_t cDvbRtp::getNumPackets() { return mNumPackets; }
uint64_t cDvbRtp::getNumErrors() { return mNumErrors; }
uint64_t cDvbRtp::getNumInvalids() { return mNumInvalids; }
uint64_t cDvbRtp::getNumDiscontinuities() { return mNumDiscontinuities; }
string cDvbRtp::getTimeString() { return mTimeString; }

int cDvbRtp::getNumOutputs() { return mOutputs.size(); }
string cDvbRtp::getOutputInfoString (int outputNum) { return mOutputs[outputNum]->getInfoString(); }
//}}}
//{{{
bool cDvbRtp::selectOutput (const string& addressString, int sid) {

  struct addrinfo* addr = parseHost (addressString.c_str(), 5002);
  if (!addr)
    return false;

  cOutputConfig outputConfig;
  outputConfig.mDisplayName = addressString;
  outputConfig.mSid = sid;
  outputConfig.mOutputDvb = true;
  outputConfig.mOutputEpg = true;

  memcpy (&outputConfig.mConnectAddr, addr->ai_addr, addr->ai_addrlen);
  outputConfig.mFamily = outputConfig.mConnectAddr.ss_family;
  freeaddrinfo (addr);

  int mtu = outputConfig.mFamily == AF_INET6 ? kDefaultIPv6Mtu : kDefaultIPv4Mtu;
  if (outputConfig.mMtu) {
    cLog::log (LOGERROR, "invalid MTU %d, setting %d", outputConfig.mMtu, mtu);
    outputConfig.mMtu = mtu;
    }
  else if (outputConfig.mMtu < kTsSize + kRtpHeaderSize)
    outputConfig.mMtu = mtu;

  // find output matching this address
  cOutput* output = findOutput (outputConfig);
  if (!output) // not found, create new
    output = createOutput (&outputConfig);

  if (output) {
    output->mConfig.mDisplayName = outputConfig.mDisplayName;
    setOutput (output, &outputConfig);
    free (outputConfig.mPids);
    return true;
    }

  free (outputConfig.mPids);
  return false;
  }
//}}}
//{{{
void cDvbRtp::demuxBlockList (cTsBlock* blockList) {
// demux transport stream block list

  // count blocks
  int numTs = 0;
  cTsBlock* block = blockList;
  while (block) {
    numTs++;
    block = block->mNextBlock;
    }

  // assume CBR, at least between two consecutive read(), especially true in budget mode
  int64_t wallclock = mdate();
  int64_t duration = (mLastDts == -1)  ? 0 : wallclock - mLastDts;

  // set blockList DTS
  block = blockList;
  int i = numTs - 1;
  while (block) {
    block->mDts = wallclock - duration * i / numTs;
    cTsBlock* nextBlock = block->mNextBlock;
    block->mNextBlock = NULL;
    demuxBlock (block);
    i--;
    block = nextBlock;
    }

  mLastDts = wallclock;
  }
//}}}
