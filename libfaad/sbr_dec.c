#include "common.h"

#ifdef SBR_DEC
  #include "structs.h"
  #include <string.h>
  #include "syntax.h"
  #include "sbr_dec.h"
  #include "sbr_sig.h"

  #ifdef PS_DEC
    #include "ps_dec.h"
  #endif

  typedef const int8_t (*sbr_huff_tab)[2];

  /*{{{*/
  /* table for Q_div values when no coupling */
  static const real_t Q_div_tab[31] = {
      FRAC_CONST(0.0153846), FRAC_CONST(0.030303),
      FRAC_CONST(0.0588235), FRAC_CONST(0.111111),
      FRAC_CONST(0.2),       FRAC_CONST(0.333333),
      FRAC_CONST(0.5),       FRAC_CONST(0.666667),
      FRAC_CONST(0.8),       FRAC_CONST(0.888889),
      FRAC_CONST(0.941176),  FRAC_CONST(0.969697),
      FRAC_CONST(0.984615),  FRAC_CONST(0.992248),
      FRAC_CONST(0.996109),  FRAC_CONST(0.998051),
      FRAC_CONST(0.999024),  FRAC_CONST(0.999512),
      FRAC_CONST(0.999756),  FRAC_CONST(0.999878),
      FRAC_CONST(0.999939),  FRAC_CONST(0.999969),
      FRAC_CONST(0.999985),  FRAC_CONST(0.999992),
      FRAC_CONST(0.999996),  FRAC_CONST(0.999998),
      FRAC_CONST(0.999999),  FRAC_CONST(1),
      FRAC_CONST(1),         FRAC_CONST(1),
      FRAC_CONST(1)
  };
  /*}}}*/
  /*{{{*/
  static const real_t Q_div_tab_left[31][13] = {
      { FRAC_CONST(0.969704), FRAC_CONST(0.888985), FRAC_CONST(0.667532), FRAC_CONST(0.336788), FRAC_CONST(0.117241), FRAC_CONST(0.037594), FRAC_CONST(0.0153846), FRAC_CONST(0.00967118), FRAC_CONST(0.00823245), FRAC_CONST(0.00787211), FRAC_CONST(0.00778198), FRAC_CONST(0.00775945), FRAC_CONST(0.00775382) },
      { FRAC_CONST(0.984619), FRAC_CONST(0.94123), FRAC_CONST(0.800623), FRAC_CONST(0.503876), FRAC_CONST(0.209877), FRAC_CONST(0.0724638), FRAC_CONST(0.030303), FRAC_CONST(0.0191571), FRAC_CONST(0.0163305), FRAC_CONST(0.0156212), FRAC_CONST(0.0154438), FRAC_CONST(0.0153994), FRAC_CONST(0.0153883) },
      { FRAC_CONST(0.99225), FRAC_CONST(0.969726), FRAC_CONST(0.889273), FRAC_CONST(0.670103), FRAC_CONST(0.346939), FRAC_CONST(0.135135), FRAC_CONST(0.0588235), FRAC_CONST(0.037594), FRAC_CONST(0.0321361), FRAC_CONST(0.0307619), FRAC_CONST(0.0304178), FRAC_CONST(0.0303317), FRAC_CONST(0.0303102) },
      { FRAC_CONST(0.99611), FRAC_CONST(0.98463), FRAC_CONST(0.941392), FRAC_CONST(0.802469), FRAC_CONST(0.515152), FRAC_CONST(0.238095), FRAC_CONST(0.111111), FRAC_CONST(0.0724638), FRAC_CONST(0.0622711), FRAC_CONST(0.0596878), FRAC_CONST(0.0590397), FRAC_CONST(0.0588776), FRAC_CONST(0.058837) },
      { FRAC_CONST(0.998051), FRAC_CONST(0.992256), FRAC_CONST(0.969811), FRAC_CONST(0.890411), FRAC_CONST(0.68), FRAC_CONST(0.384615), FRAC_CONST(0.2), FRAC_CONST(0.135135), FRAC_CONST(0.117241), FRAC_CONST(0.112652), FRAC_CONST(0.111497), FRAC_CONST(0.111208), FRAC_CONST(0.111135) },
      { FRAC_CONST(0.999025), FRAC_CONST(0.996113), FRAC_CONST(0.984674), FRAC_CONST(0.942029), FRAC_CONST(0.809524), FRAC_CONST(0.555556), FRAC_CONST(0.333333), FRAC_CONST(0.238095), FRAC_CONST(0.209877), FRAC_CONST(0.202492), FRAC_CONST(0.200625), FRAC_CONST(0.200156), FRAC_CONST(0.200039) },
      { FRAC_CONST(0.999512), FRAC_CONST(0.998053), FRAC_CONST(0.992278), FRAC_CONST(0.970149), FRAC_CONST(0.894737), FRAC_CONST(0.714286), FRAC_CONST(0.5), FRAC_CONST(0.384615), FRAC_CONST(0.346939), FRAC_CONST(0.336788), FRAC_CONST(0.3342), FRAC_CONST(0.33355), FRAC_CONST(0.333388) },
      { FRAC_CONST(0.999756), FRAC_CONST(0.999025), FRAC_CONST(0.996124), FRAC_CONST(0.984848), FRAC_CONST(0.944444), FRAC_CONST(0.833333), FRAC_CONST(0.666667), FRAC_CONST(0.555556), FRAC_CONST(0.515152), FRAC_CONST(0.503876), FRAC_CONST(0.500975), FRAC_CONST(0.500244), FRAC_CONST(0.500061) },
      { FRAC_CONST(0.999878), FRAC_CONST(0.999512), FRAC_CONST(0.998058), FRAC_CONST(0.992366), FRAC_CONST(0.971429), FRAC_CONST(0.909091), FRAC_CONST(0.8), FRAC_CONST(0.714286), FRAC_CONST(0.68), FRAC_CONST(0.670103), FRAC_CONST(0.667532), FRAC_CONST(0.666884), FRAC_CONST(0.666721) },
      { FRAC_CONST(0.999939), FRAC_CONST(0.999756), FRAC_CONST(0.999028), FRAC_CONST(0.996169), FRAC_CONST(0.985507), FRAC_CONST(0.952381), FRAC_CONST(0.888889), FRAC_CONST(0.833333), FRAC_CONST(0.809524), FRAC_CONST(0.802469), FRAC_CONST(0.800623), FRAC_CONST(0.800156), FRAC_CONST(0.800039) },
      { FRAC_CONST(0.999969), FRAC_CONST(0.999878), FRAC_CONST(0.999514), FRAC_CONST(0.998081), FRAC_CONST(0.992701), FRAC_CONST(0.97561), FRAC_CONST(0.941176), FRAC_CONST(0.909091), FRAC_CONST(0.894737), FRAC_CONST(0.890411), FRAC_CONST(0.889273), FRAC_CONST(0.888985), FRAC_CONST(0.888913) },
      { FRAC_CONST(0.999985), FRAC_CONST(0.999939), FRAC_CONST(0.999757), FRAC_CONST(0.999039), FRAC_CONST(0.996337), FRAC_CONST(0.987654), FRAC_CONST(0.969697), FRAC_CONST(0.952381), FRAC_CONST(0.944444), FRAC_CONST(0.942029), FRAC_CONST(0.941392), FRAC_CONST(0.94123), FRAC_CONST(0.94119) },
      { FRAC_CONST(0.999992), FRAC_CONST(0.99997), FRAC_CONST(0.999878), FRAC_CONST(0.999519), FRAC_CONST(0.998165), FRAC_CONST(0.993789), FRAC_CONST(0.984615), FRAC_CONST(0.97561), FRAC_CONST(0.971429), FRAC_CONST(0.970149), FRAC_CONST(0.969811), FRAC_CONST(0.969726), FRAC_CONST(0.969704) },
      { FRAC_CONST(0.999996), FRAC_CONST(0.999985), FRAC_CONST(0.999939), FRAC_CONST(0.99976), FRAC_CONST(0.999082), FRAC_CONST(0.996885), FRAC_CONST(0.992248), FRAC_CONST(0.987654), FRAC_CONST(0.985507), FRAC_CONST(0.984848), FRAC_CONST(0.984674), FRAC_CONST(0.98463), FRAC_CONST(0.984619) },
      { FRAC_CONST(0.999998), FRAC_CONST(0.999992), FRAC_CONST(0.99997), FRAC_CONST(0.99988), FRAC_CONST(0.999541), FRAC_CONST(0.99844), FRAC_CONST(0.996109), FRAC_CONST(0.993789), FRAC_CONST(0.992701), FRAC_CONST(0.992366), FRAC_CONST(0.992278), FRAC_CONST(0.992256), FRAC_CONST(0.99225) },
      { FRAC_CONST(0.999999), FRAC_CONST(0.999996), FRAC_CONST(0.999985), FRAC_CONST(0.99994), FRAC_CONST(0.99977), FRAC_CONST(0.999219), FRAC_CONST(0.998051), FRAC_CONST(0.996885), FRAC_CONST(0.996337), FRAC_CONST(0.996169), FRAC_CONST(0.996124), FRAC_CONST(0.996113), FRAC_CONST(0.99611) },
      { FRAC_CONST(1), FRAC_CONST(0.999998), FRAC_CONST(0.999992), FRAC_CONST(0.99997), FRAC_CONST(0.999885), FRAC_CONST(0.99961), FRAC_CONST(0.999024), FRAC_CONST(0.99844), FRAC_CONST(0.998165), FRAC_CONST(0.998081), FRAC_CONST(0.998058), FRAC_CONST(0.998053), FRAC_CONST(0.998051) },
      { FRAC_CONST(1), FRAC_CONST(0.999999), FRAC_CONST(0.999996), FRAC_CONST(0.999985), FRAC_CONST(0.999943), FRAC_CONST(0.999805), FRAC_CONST(0.999512), FRAC_CONST(0.999219), FRAC_CONST(0.999082), FRAC_CONST(0.999039), FRAC_CONST(0.999028), FRAC_CONST(0.999025), FRAC_CONST(0.999025) },
      { FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(0.999998), FRAC_CONST(0.999992), FRAC_CONST(0.999971), FRAC_CONST(0.999902), FRAC_CONST(0.999756), FRAC_CONST(0.99961), FRAC_CONST(0.999541), FRAC_CONST(0.999519), FRAC_CONST(0.999514), FRAC_CONST(0.999512), FRAC_CONST(0.999512) },
      { FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(0.999999), FRAC_CONST(0.999996), FRAC_CONST(0.999986), FRAC_CONST(0.999951), FRAC_CONST(0.999878), FRAC_CONST(0.999805), FRAC_CONST(0.99977), FRAC_CONST(0.99976), FRAC_CONST(0.999757), FRAC_CONST(0.999756), FRAC_CONST(0.999756) },
      { FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(0.999998), FRAC_CONST(0.999993), FRAC_CONST(0.999976), FRAC_CONST(0.999939), FRAC_CONST(0.999902), FRAC_CONST(0.999885), FRAC_CONST(0.99988), FRAC_CONST(0.999878), FRAC_CONST(0.999878), FRAC_CONST(0.999878) },
      { FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(0.999999), FRAC_CONST(0.999996), FRAC_CONST(0.999988), FRAC_CONST(0.999969), FRAC_CONST(0.999951), FRAC_CONST(0.999943), FRAC_CONST(0.99994), FRAC_CONST(0.999939), FRAC_CONST(0.999939), FRAC_CONST(0.999939) },
      { FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(0.999998), FRAC_CONST(0.999994), FRAC_CONST(0.999985), FRAC_CONST(0.999976), FRAC_CONST(0.999971), FRAC_CONST(0.99997), FRAC_CONST(0.99997), FRAC_CONST(0.99997), FRAC_CONST(0.999969) },
      { FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(0.999999), FRAC_CONST(0.999997), FRAC_CONST(0.999992), FRAC_CONST(0.999988), FRAC_CONST(0.999986), FRAC_CONST(0.999985), FRAC_CONST(0.999985), FRAC_CONST(0.999985), FRAC_CONST(0.999985) },
      { FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(0.999998), FRAC_CONST(0.999996), FRAC_CONST(0.999994), FRAC_CONST(0.999993), FRAC_CONST(0.999992), FRAC_CONST(0.999992), FRAC_CONST(0.999992), FRAC_CONST(0.999992) },
      { FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(0.999999), FRAC_CONST(0.999998), FRAC_CONST(0.999997), FRAC_CONST(0.999996), FRAC_CONST(0.999996), FRAC_CONST(0.999996), FRAC_CONST(0.999996), FRAC_CONST(0.999996) },
      { FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(0.999999), FRAC_CONST(0.999998), FRAC_CONST(0.999998), FRAC_CONST(0.999998), FRAC_CONST(0.999998), FRAC_CONST(0.999998), FRAC_CONST(0.999998) },
      { FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(0.999999), FRAC_CONST(0.999999), FRAC_CONST(0.999999), FRAC_CONST(0.999999), FRAC_CONST(0.999999), FRAC_CONST(0.999999) },
      { FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1) },
      { FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1) },
      { FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1) }
  };
  /*}}}*/
  /*{{{*/
  static const real_t Q_div_tab_right[31][13] = {
      { FRAC_CONST(0.00775382), FRAC_CONST(0.00775945), FRAC_CONST(0.00778198), FRAC_CONST(0.00787211), FRAC_CONST(0.00823245), FRAC_CONST(0.00967118), FRAC_CONST(0.0153846), FRAC_CONST(0.037594), FRAC_CONST(0.117241), FRAC_CONST(0.336788), FRAC_CONST(0.667532), FRAC_CONST(0.888985), FRAC_CONST(0.969704) },
      { FRAC_CONST(0.0153883), FRAC_CONST(0.0153994), FRAC_CONST(0.0154438), FRAC_CONST(0.0156212), FRAC_CONST(0.0163305), FRAC_CONST(0.0191571), FRAC_CONST(0.030303), FRAC_CONST(0.0724638), FRAC_CONST(0.209877), FRAC_CONST(0.503876), FRAC_CONST(0.800623), FRAC_CONST(0.94123), FRAC_CONST(0.984619) },
      { FRAC_CONST(0.0303102), FRAC_CONST(0.0303317), FRAC_CONST(0.0304178), FRAC_CONST(0.0307619), FRAC_CONST(0.0321361), FRAC_CONST(0.037594), FRAC_CONST(0.0588235), FRAC_CONST(0.135135), FRAC_CONST(0.346939), FRAC_CONST(0.670103), FRAC_CONST(0.889273), FRAC_CONST(0.969726), FRAC_CONST(0.99225) },
      { FRAC_CONST(0.058837), FRAC_CONST(0.0588776), FRAC_CONST(0.0590397), FRAC_CONST(0.0596878), FRAC_CONST(0.0622711), FRAC_CONST(0.0724638), FRAC_CONST(0.111111), FRAC_CONST(0.238095), FRAC_CONST(0.515152), FRAC_CONST(0.802469), FRAC_CONST(0.941392), FRAC_CONST(0.98463), FRAC_CONST(0.99611) },
      { FRAC_CONST(0.111135), FRAC_CONST(0.111208), FRAC_CONST(0.111497), FRAC_CONST(0.112652), FRAC_CONST(0.117241), FRAC_CONST(0.135135), FRAC_CONST(0.2), FRAC_CONST(0.384615), FRAC_CONST(0.68), FRAC_CONST(0.890411), FRAC_CONST(0.969811), FRAC_CONST(0.992256), FRAC_CONST(0.998051) },
      { FRAC_CONST(0.200039), FRAC_CONST(0.200156), FRAC_CONST(0.200625), FRAC_CONST(0.202492), FRAC_CONST(0.209877), FRAC_CONST(0.238095), FRAC_CONST(0.333333), FRAC_CONST(0.555556), FRAC_CONST(0.809524), FRAC_CONST(0.942029), FRAC_CONST(0.984674), FRAC_CONST(0.996113), FRAC_CONST(0.999025) },
      { FRAC_CONST(0.333388), FRAC_CONST(0.33355), FRAC_CONST(0.3342), FRAC_CONST(0.336788), FRAC_CONST(0.346939), FRAC_CONST(0.384615), FRAC_CONST(0.5), FRAC_CONST(0.714286), FRAC_CONST(0.894737), FRAC_CONST(0.970149), FRAC_CONST(0.992278), FRAC_CONST(0.998053), FRAC_CONST(0.999512) },
      { FRAC_CONST(0.500061), FRAC_CONST(0.500244), FRAC_CONST(0.500975), FRAC_CONST(0.503876), FRAC_CONST(0.515152), FRAC_CONST(0.555556), FRAC_CONST(0.666667), FRAC_CONST(0.833333), FRAC_CONST(0.944444), FRAC_CONST(0.984848), FRAC_CONST(0.996124), FRAC_CONST(0.999025), FRAC_CONST(0.999756) },
      { FRAC_CONST(0.666721), FRAC_CONST(0.666884), FRAC_CONST(0.667532), FRAC_CONST(0.670103), FRAC_CONST(0.68), FRAC_CONST(0.714286), FRAC_CONST(0.8), FRAC_CONST(0.909091), FRAC_CONST(0.971429), FRAC_CONST(0.992366), FRAC_CONST(0.998058), FRAC_CONST(0.999512), FRAC_CONST(0.999878) },
      { FRAC_CONST(0.800039), FRAC_CONST(0.800156), FRAC_CONST(0.800623), FRAC_CONST(0.802469), FRAC_CONST(0.809524), FRAC_CONST(0.833333), FRAC_CONST(0.888889), FRAC_CONST(0.952381), FRAC_CONST(0.985507), FRAC_CONST(0.996169), FRAC_CONST(0.999028), FRAC_CONST(0.999756), FRAC_CONST(0.999939) },
      { FRAC_CONST(0.888913), FRAC_CONST(0.888985), FRAC_CONST(0.889273), FRAC_CONST(0.890411), FRAC_CONST(0.894737), FRAC_CONST(0.909091), FRAC_CONST(0.941176), FRAC_CONST(0.97561), FRAC_CONST(0.992701), FRAC_CONST(0.998081), FRAC_CONST(0.999514), FRAC_CONST(0.999878), FRAC_CONST(0.999969) },
      { FRAC_CONST(0.94119), FRAC_CONST(0.94123), FRAC_CONST(0.941392), FRAC_CONST(0.942029), FRAC_CONST(0.944444), FRAC_CONST(0.952381), FRAC_CONST(0.969697), FRAC_CONST(0.987654), FRAC_CONST(0.996337), FRAC_CONST(0.999039), FRAC_CONST(0.999757), FRAC_CONST(0.999939), FRAC_CONST(0.999985) },
      { FRAC_CONST(0.969704), FRAC_CONST(0.969726), FRAC_CONST(0.969811), FRAC_CONST(0.970149), FRAC_CONST(0.971429), FRAC_CONST(0.97561), FRAC_CONST(0.984615), FRAC_CONST(0.993789), FRAC_CONST(0.998165), FRAC_CONST(0.999519), FRAC_CONST(0.999878), FRAC_CONST(0.99997), FRAC_CONST(0.999992) },
      { FRAC_CONST(0.984619), FRAC_CONST(0.98463), FRAC_CONST(0.984674), FRAC_CONST(0.984848), FRAC_CONST(0.985507), FRAC_CONST(0.987654), FRAC_CONST(0.992248), FRAC_CONST(0.996885), FRAC_CONST(0.999082), FRAC_CONST(0.99976), FRAC_CONST(0.999939), FRAC_CONST(0.999985), FRAC_CONST(0.999996) },
      { FRAC_CONST(0.99225), FRAC_CONST(0.992256), FRAC_CONST(0.992278), FRAC_CONST(0.992366), FRAC_CONST(0.992701), FRAC_CONST(0.993789), FRAC_CONST(0.996109), FRAC_CONST(0.99844), FRAC_CONST(0.999541), FRAC_CONST(0.99988), FRAC_CONST(0.99997), FRAC_CONST(0.999992), FRAC_CONST(0.999998) },
      { FRAC_CONST(0.99611), FRAC_CONST(0.996113), FRAC_CONST(0.996124), FRAC_CONST(0.996169), FRAC_CONST(0.996337), FRAC_CONST(0.996885), FRAC_CONST(0.998051), FRAC_CONST(0.999219), FRAC_CONST(0.99977), FRAC_CONST(0.99994), FRAC_CONST(0.999985), FRAC_CONST(0.999996), FRAC_CONST(0.999999) },
      { FRAC_CONST(0.998051), FRAC_CONST(0.998053), FRAC_CONST(0.998058), FRAC_CONST(0.998081), FRAC_CONST(0.998165), FRAC_CONST(0.99844), FRAC_CONST(0.999024), FRAC_CONST(0.99961), FRAC_CONST(0.999885), FRAC_CONST(0.99997), FRAC_CONST(0.999992), FRAC_CONST(0.999998), FRAC_CONST(1) },
      { FRAC_CONST(0.999025), FRAC_CONST(0.999025), FRAC_CONST(0.999028), FRAC_CONST(0.999039), FRAC_CONST(0.999082), FRAC_CONST(0.999219), FRAC_CONST(0.999512), FRAC_CONST(0.999805), FRAC_CONST(0.999943), FRAC_CONST(0.999985), FRAC_CONST(0.999996), FRAC_CONST(0.999999), FRAC_CONST(1) },
      { FRAC_CONST(0.999512), FRAC_CONST(0.999512), FRAC_CONST(0.999514), FRAC_CONST(0.999519), FRAC_CONST(0.999541), FRAC_CONST(0.99961), FRAC_CONST(0.999756), FRAC_CONST(0.999902), FRAC_CONST(0.999971), FRAC_CONST(0.999992), FRAC_CONST(0.999998), FRAC_CONST(1), FRAC_CONST(1) },
      { FRAC_CONST(0.999756), FRAC_CONST(0.999756), FRAC_CONST(0.999757), FRAC_CONST(0.99976), FRAC_CONST(0.99977), FRAC_CONST(0.999805), FRAC_CONST(0.999878), FRAC_CONST(0.999951), FRAC_CONST(0.999986), FRAC_CONST(0.999996), FRAC_CONST(0.999999), FRAC_CONST(1), FRAC_CONST(1) },
      { FRAC_CONST(0.999878), FRAC_CONST(0.999878), FRAC_CONST(0.999878), FRAC_CONST(0.99988), FRAC_CONST(0.999885), FRAC_CONST(0.999902), FRAC_CONST(0.999939), FRAC_CONST(0.999976), FRAC_CONST(0.999993), FRAC_CONST(0.999998), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1) },
      { FRAC_CONST(0.999939), FRAC_CONST(0.999939), FRAC_CONST(0.999939), FRAC_CONST(0.99994), FRAC_CONST(0.999943), FRAC_CONST(0.999951), FRAC_CONST(0.999969), FRAC_CONST(0.999988), FRAC_CONST(0.999996), FRAC_CONST(0.999999), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1) },
      { FRAC_CONST(0.999969), FRAC_CONST(0.99997), FRAC_CONST(0.99997), FRAC_CONST(0.99997), FRAC_CONST(0.999971), FRAC_CONST(0.999976), FRAC_CONST(0.999985), FRAC_CONST(0.999994), FRAC_CONST(0.999998), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1) },
      { FRAC_CONST(0.999985), FRAC_CONST(0.999985), FRAC_CONST(0.999985), FRAC_CONST(0.999985), FRAC_CONST(0.999986), FRAC_CONST(0.999988), FRAC_CONST(0.999992), FRAC_CONST(0.999997), FRAC_CONST(0.999999), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1) },
      { FRAC_CONST(0.999992), FRAC_CONST(0.999992), FRAC_CONST(0.999992), FRAC_CONST(0.999992), FRAC_CONST(0.999993), FRAC_CONST(0.999994), FRAC_CONST(0.999996), FRAC_CONST(0.999998), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1) },
      { FRAC_CONST(0.999996), FRAC_CONST(0.999996), FRAC_CONST(0.999996), FRAC_CONST(0.999996), FRAC_CONST(0.999996), FRAC_CONST(0.999997), FRAC_CONST(0.999998), FRAC_CONST(0.999999), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1) },
      { FRAC_CONST(0.999998), FRAC_CONST(0.999998), FRAC_CONST(0.999998), FRAC_CONST(0.999998), FRAC_CONST(0.999998), FRAC_CONST(0.999998), FRAC_CONST(0.999999), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1) },
      { FRAC_CONST(0.999999), FRAC_CONST(0.999999), FRAC_CONST(0.999999), FRAC_CONST(0.999999), FRAC_CONST(0.999999), FRAC_CONST(0.999999), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1) },
      { FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1) },
      { FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1) },
      { FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1), FRAC_CONST(1) }
  };
  /*}}}*/
  /*{{{*/
  /* calculates 1/(1+Q) */
  /* [0..1] */
  static real_t calc_Q_div(sbr_info *sbr, uint8_t ch, uint8_t m, uint8_t l)
  {
      if (sbr->bs_coupling)
      {
          /* left channel */
          if ((sbr->Q[0][m][l] < 0 || sbr->Q[0][m][l] > 30) ||
              (sbr->Q[1][m][l] < 0 || sbr->Q[1][m][l] > 24 /* 2*panOffset(1) */))
          {
              return 0;
          } else {
              /* the pan parameter is always even */
              if (ch == 0)
              {
                  return Q_div_tab_left[sbr->Q[0][m][l]][sbr->Q[1][m][l] >> 1];
              } else {
                  return Q_div_tab_right[sbr->Q[0][m][l]][sbr->Q[1][m][l] >> 1];
              }
          }
      } else {
          /* no coupling */
          if (sbr->Q[ch][m][l] < 0 || sbr->Q[ch][m][l] > 30)
          {
              return 0;
          } else {
              return Q_div_tab[sbr->Q[ch][m][l]];
          }
      }
  }
  /*}}}*/
  /*{{{*/
  /* table for Q_div2 values when no coupling */
  static const real_t Q_div2_tab[31] = {
      FRAC_CONST(0.984615),     FRAC_CONST(0.969697),
      FRAC_CONST(0.941176),     FRAC_CONST(0.888889),
      FRAC_CONST(0.8),          FRAC_CONST(0.666667),
      FRAC_CONST(0.5),          FRAC_CONST(0.333333),
      FRAC_CONST(0.2),          FRAC_CONST(0.111111),
      FRAC_CONST(0.0588235),    FRAC_CONST(0.030303),
      FRAC_CONST(0.0153846),    FRAC_CONST(0.00775194),
      FRAC_CONST(0.00389105),   FRAC_CONST(0.00194932),
      FRAC_CONST(0.00097561),   FRAC_CONST(0.000488043),
      FRAC_CONST(0.000244081),  FRAC_CONST(0.000122055),
      FRAC_CONST(6.10314E-005), FRAC_CONST(3.05166E-005),
      FRAC_CONST(1.52586E-005), FRAC_CONST(7.62934E-006),
      FRAC_CONST(3.81468E-006), FRAC_CONST(1.90734E-006),
      FRAC_CONST(9.53673E-007), FRAC_CONST(4.76837E-007),
      FRAC_CONST(2.38419E-007), FRAC_CONST(1.19209E-007),
      FRAC_CONST(5.96046E-008)
  };
  /*}}}*/
  /*{{{*/
  static const real_t Q_div2_tab_left[31][13] = {
      { FRAC_CONST(0.0302959), FRAC_CONST(0.111015), FRAC_CONST(0.332468), FRAC_CONST(0.663212), FRAC_CONST(0.882759), FRAC_CONST(0.962406), FRAC_CONST(0.984615), FRAC_CONST(0.990329), FRAC_CONST(0.991768), FRAC_CONST(0.992128), FRAC_CONST(0.992218), FRAC_CONST(0.992241), FRAC_CONST(0.992246) },
      { FRAC_CONST(0.0153809), FRAC_CONST(0.0587695), FRAC_CONST(0.199377), FRAC_CONST(0.496124), FRAC_CONST(0.790123), FRAC_CONST(0.927536), FRAC_CONST(0.969697), FRAC_CONST(0.980843), FRAC_CONST(0.98367), FRAC_CONST(0.984379), FRAC_CONST(0.984556), FRAC_CONST(0.984601), FRAC_CONST(0.984612) },
      { FRAC_CONST(0.00775006), FRAC_CONST(0.0302744), FRAC_CONST(0.110727), FRAC_CONST(0.329897), FRAC_CONST(0.653061), FRAC_CONST(0.864865), FRAC_CONST(0.941176), FRAC_CONST(0.962406), FRAC_CONST(0.967864), FRAC_CONST(0.969238), FRAC_CONST(0.969582), FRAC_CONST(0.969668), FRAC_CONST(0.96969) },
      { FRAC_CONST(0.0038901), FRAC_CONST(0.0153698), FRAC_CONST(0.0586081), FRAC_CONST(0.197531), FRAC_CONST(0.484848), FRAC_CONST(0.761905), FRAC_CONST(0.888889), FRAC_CONST(0.927536), FRAC_CONST(0.937729), FRAC_CONST(0.940312), FRAC_CONST(0.94096), FRAC_CONST(0.941122), FRAC_CONST(0.941163) },
      { FRAC_CONST(0.00194884), FRAC_CONST(0.00774443), FRAC_CONST(0.0301887), FRAC_CONST(0.109589), FRAC_CONST(0.32), FRAC_CONST(0.615385), FRAC_CONST(0.8), FRAC_CONST(0.864865), FRAC_CONST(0.882759), FRAC_CONST(0.887348), FRAC_CONST(0.888503), FRAC_CONST(0.888792), FRAC_CONST(0.888865) },
      { FRAC_CONST(0.000975372), FRAC_CONST(0.00388727), FRAC_CONST(0.0153257), FRAC_CONST(0.057971), FRAC_CONST(0.190476), FRAC_CONST(0.444444), FRAC_CONST(0.666667), FRAC_CONST(0.761905), FRAC_CONST(0.790123), FRAC_CONST(0.797508), FRAC_CONST(0.799375), FRAC_CONST(0.799844), FRAC_CONST(0.799961) },
      { FRAC_CONST(0.000487924), FRAC_CONST(0.00194742), FRAC_CONST(0.00772201), FRAC_CONST(0.0298507), FRAC_CONST(0.105263), FRAC_CONST(0.285714), FRAC_CONST(0.5), FRAC_CONST(0.615385), FRAC_CONST(0.653061), FRAC_CONST(0.663212), FRAC_CONST(0.6658), FRAC_CONST(0.66645), FRAC_CONST(0.666612) },
      { FRAC_CONST(0.000244021), FRAC_CONST(0.000974659), FRAC_CONST(0.00387597), FRAC_CONST(0.0151515), FRAC_CONST(0.0555556), FRAC_CONST(0.166667), FRAC_CONST(0.333333), FRAC_CONST(0.444444), FRAC_CONST(0.484848), FRAC_CONST(0.496124), FRAC_CONST(0.499025), FRAC_CONST(0.499756), FRAC_CONST(0.499939) },
      { FRAC_CONST(0.000122026), FRAC_CONST(0.000487567), FRAC_CONST(0.00194175), FRAC_CONST(0.00763359), FRAC_CONST(0.0285714), FRAC_CONST(0.0909091), FRAC_CONST(0.2), FRAC_CONST(0.285714), FRAC_CONST(0.32), FRAC_CONST(0.329897), FRAC_CONST(0.332468), FRAC_CONST(0.333116), FRAC_CONST(0.333279) },
      { FRAC_CONST(6.10165E-005), FRAC_CONST(0.000243843), FRAC_CONST(0.000971817), FRAC_CONST(0.00383142), FRAC_CONST(0.0144928), FRAC_CONST(0.047619), FRAC_CONST(0.111111), FRAC_CONST(0.166667), FRAC_CONST(0.190476), FRAC_CONST(0.197531), FRAC_CONST(0.199377), FRAC_CONST(0.199844), FRAC_CONST(0.199961) },
      { FRAC_CONST(3.05092E-005), FRAC_CONST(0.000121936), FRAC_CONST(0.000486145), FRAC_CONST(0.00191939), FRAC_CONST(0.00729927), FRAC_CONST(0.0243902), FRAC_CONST(0.0588235), FRAC_CONST(0.0909091), FRAC_CONST(0.105263), FRAC_CONST(0.109589), FRAC_CONST(0.110727), FRAC_CONST(0.111015), FRAC_CONST(0.111087) },
      { FRAC_CONST(1.52548E-005), FRAC_CONST(6.09719E-005), FRAC_CONST(0.000243132), FRAC_CONST(0.000960615), FRAC_CONST(0.003663), FRAC_CONST(0.0123457), FRAC_CONST(0.030303), FRAC_CONST(0.047619), FRAC_CONST(0.0555556), FRAC_CONST(0.057971), FRAC_CONST(0.0586081), FRAC_CONST(0.0587695), FRAC_CONST(0.05881) },
      { FRAC_CONST(7.62747E-006), FRAC_CONST(3.04869E-005), FRAC_CONST(0.000121581), FRAC_CONST(0.000480538), FRAC_CONST(0.00183486), FRAC_CONST(0.00621118), FRAC_CONST(0.0153846), FRAC_CONST(0.0243902), FRAC_CONST(0.0285714), FRAC_CONST(0.0298507), FRAC_CONST(0.0301887), FRAC_CONST(0.0302744), FRAC_CONST(0.0302959) },
      { FRAC_CONST(3.81375E-006), FRAC_CONST(1.52437E-005), FRAC_CONST(6.0794E-005), FRAC_CONST(0.000240327), FRAC_CONST(0.000918274), FRAC_CONST(0.00311526), FRAC_CONST(0.00775194), FRAC_CONST(0.0123457), FRAC_CONST(0.0144928), FRAC_CONST(0.0151515), FRAC_CONST(0.0153257), FRAC_CONST(0.0153698), FRAC_CONST(0.0153809) },
      { FRAC_CONST(1.90688E-006), FRAC_CONST(7.62189E-006), FRAC_CONST(3.03979E-005), FRAC_CONST(0.000120178), FRAC_CONST(0.000459348), FRAC_CONST(0.00156006), FRAC_CONST(0.00389105), FRAC_CONST(0.00621118), FRAC_CONST(0.00729927), FRAC_CONST(0.00763359), FRAC_CONST(0.00772201), FRAC_CONST(0.00774443), FRAC_CONST(0.00775006) },
      { FRAC_CONST(9.53441E-007), FRAC_CONST(3.81096E-006), FRAC_CONST(1.51992E-005), FRAC_CONST(6.00925E-005), FRAC_CONST(0.000229727), FRAC_CONST(0.00078064), FRAC_CONST(0.00194932), FRAC_CONST(0.00311526), FRAC_CONST(0.003663), FRAC_CONST(0.00383142), FRAC_CONST(0.00387597), FRAC_CONST(0.00388727), FRAC_CONST(0.0038901) },
      { FRAC_CONST(4.76721E-007), FRAC_CONST(1.90548E-006), FRAC_CONST(7.59965E-006), FRAC_CONST(3.00472E-005), FRAC_CONST(0.000114877), FRAC_CONST(0.000390472), FRAC_CONST(0.00097561), FRAC_CONST(0.00156006), FRAC_CONST(0.00183486), FRAC_CONST(0.00191939), FRAC_CONST(0.00194175), FRAC_CONST(0.00194742), FRAC_CONST(0.00194884) },
      { FRAC_CONST(2.3836E-007), FRAC_CONST(9.52743E-007), FRAC_CONST(3.79984E-006), FRAC_CONST(1.50238E-005), FRAC_CONST(5.74416E-005), FRAC_CONST(0.000195274), FRAC_CONST(0.000488043), FRAC_CONST(0.00078064), FRAC_CONST(0.000918274), FRAC_CONST(0.000960615), FRAC_CONST(0.000971817), FRAC_CONST(0.000974659), FRAC_CONST(0.000975372) },
      { FRAC_CONST(1.1918E-007), FRAC_CONST(4.76372E-007), FRAC_CONST(1.89992E-006), FRAC_CONST(7.51196E-006), FRAC_CONST(2.87216E-005), FRAC_CONST(9.76467E-005), FRAC_CONST(0.000244081), FRAC_CONST(0.000390472), FRAC_CONST(0.000459348), FRAC_CONST(0.000480538), FRAC_CONST(0.000486145), FRAC_CONST(0.000487567), FRAC_CONST(0.000487924) },
      { FRAC_CONST(5.95901E-008), FRAC_CONST(2.38186E-007), FRAC_CONST(9.49963E-007), FRAC_CONST(3.756E-006), FRAC_CONST(1.4361E-005), FRAC_CONST(4.88257E-005), FRAC_CONST(0.000122055), FRAC_CONST(0.000195274), FRAC_CONST(0.000229727), FRAC_CONST(0.000240327), FRAC_CONST(0.000243132), FRAC_CONST(0.000243843), FRAC_CONST(0.000244021) },
      { FRAC_CONST(2.9795E-008), FRAC_CONST(1.19093E-007), FRAC_CONST(4.74982E-007), FRAC_CONST(1.878E-006), FRAC_CONST(7.18056E-006), FRAC_CONST(2.44135E-005), FRAC_CONST(6.10314E-005), FRAC_CONST(9.76467E-005), FRAC_CONST(0.000114877), FRAC_CONST(0.000120178), FRAC_CONST(0.000121581), FRAC_CONST(0.000121936), FRAC_CONST(0.000122026) },
      { FRAC_CONST(1.48975E-008), FRAC_CONST(5.95465E-008), FRAC_CONST(2.37491E-007), FRAC_CONST(9.39002E-007), FRAC_CONST(3.59029E-006), FRAC_CONST(1.22069E-005), FRAC_CONST(3.05166E-005), FRAC_CONST(4.88257E-005), FRAC_CONST(5.74416E-005), FRAC_CONST(6.00925E-005), FRAC_CONST(6.0794E-005), FRAC_CONST(6.09719E-005), FRAC_CONST(6.10165E-005) },
      { FRAC_CONST(7.44876E-009), FRAC_CONST(2.97732E-008), FRAC_CONST(1.18745E-007), FRAC_CONST(4.69501E-007), FRAC_CONST(1.79515E-006), FRAC_CONST(6.10348E-006), FRAC_CONST(1.52586E-005), FRAC_CONST(2.44135E-005), FRAC_CONST(2.87216E-005), FRAC_CONST(3.00472E-005), FRAC_CONST(3.03979E-005), FRAC_CONST(3.04869E-005), FRAC_CONST(3.05092E-005) },
      { FRAC_CONST(3.72438E-009), FRAC_CONST(1.48866E-008), FRAC_CONST(5.93727E-008), FRAC_CONST(2.34751E-007), FRAC_CONST(8.97575E-007), FRAC_CONST(3.05175E-006), FRAC_CONST(7.62934E-006), FRAC_CONST(1.22069E-005), FRAC_CONST(1.4361E-005), FRAC_CONST(1.50238E-005), FRAC_CONST(1.51992E-005), FRAC_CONST(1.52437E-005), FRAC_CONST(1.52548E-005) },
      { FRAC_CONST(1.86219E-009), FRAC_CONST(7.44331E-009), FRAC_CONST(2.96864E-008), FRAC_CONST(1.17375E-007), FRAC_CONST(4.48788E-007), FRAC_CONST(1.52588E-006), FRAC_CONST(3.81468E-006), FRAC_CONST(6.10348E-006), FRAC_CONST(7.18056E-006), FRAC_CONST(7.51196E-006), FRAC_CONST(7.59965E-006), FRAC_CONST(7.62189E-006), FRAC_CONST(7.62747E-006) },
      { FRAC_CONST(9.31095E-010), FRAC_CONST(3.72166E-009), FRAC_CONST(1.48432E-008), FRAC_CONST(5.86876E-008), FRAC_CONST(2.24394E-007), FRAC_CONST(7.62939E-007), FRAC_CONST(1.90734E-006), FRAC_CONST(3.05175E-006), FRAC_CONST(3.59029E-006), FRAC_CONST(3.756E-006), FRAC_CONST(3.79984E-006), FRAC_CONST(3.81096E-006), FRAC_CONST(3.81375E-006) },
      { FRAC_CONST(4.65548E-010), FRAC_CONST(1.86083E-009), FRAC_CONST(7.42159E-009), FRAC_CONST(2.93438E-008), FRAC_CONST(1.12197E-007), FRAC_CONST(3.8147E-007), FRAC_CONST(9.53673E-007), FRAC_CONST(1.52588E-006), FRAC_CONST(1.79515E-006), FRAC_CONST(1.878E-006), FRAC_CONST(1.89992E-006), FRAC_CONST(1.90548E-006), FRAC_CONST(1.90688E-006) },
      { FRAC_CONST(2.32774E-010), FRAC_CONST(9.30414E-010), FRAC_CONST(3.71079E-009), FRAC_CONST(1.46719E-008), FRAC_CONST(5.60985E-008), FRAC_CONST(1.90735E-007), FRAC_CONST(4.76837E-007), FRAC_CONST(7.62939E-007), FRAC_CONST(8.97575E-007), FRAC_CONST(9.39002E-007), FRAC_CONST(9.49963E-007), FRAC_CONST(9.52743E-007), FRAC_CONST(9.53441E-007) },
      { FRAC_CONST(1.16387E-010), FRAC_CONST(4.65207E-010), FRAC_CONST(1.8554E-009), FRAC_CONST(7.33596E-009), FRAC_CONST(2.80492E-008), FRAC_CONST(9.53674E-008), FRAC_CONST(2.38419E-007), FRAC_CONST(3.8147E-007), FRAC_CONST(4.48788E-007), FRAC_CONST(4.69501E-007), FRAC_CONST(4.74982E-007), FRAC_CONST(4.76372E-007), FRAC_CONST(4.76721E-007) },
      { FRAC_CONST(5.81935E-011), FRAC_CONST(2.32603E-010), FRAC_CONST(9.27699E-010), FRAC_CONST(3.66798E-009), FRAC_CONST(1.40246E-008), FRAC_CONST(4.76837E-008), FRAC_CONST(1.19209E-007), FRAC_CONST(1.90735E-007), FRAC_CONST(2.24394E-007), FRAC_CONST(2.34751E-007), FRAC_CONST(2.37491E-007), FRAC_CONST(2.38186E-007), FRAC_CONST(2.3836E-007) },
      { FRAC_CONST(2.90967E-011), FRAC_CONST(1.16302E-010), FRAC_CONST(4.63849E-010), FRAC_CONST(1.83399E-009), FRAC_CONST(7.01231E-009), FRAC_CONST(2.38419E-008), FRAC_CONST(5.96046E-008), FRAC_CONST(9.53674E-008), FRAC_CONST(1.12197E-007), FRAC_CONST(1.17375E-007), FRAC_CONST(1.18745E-007), FRAC_CONST(1.19093E-007), FRAC_CONST(1.1918E-007) }
  };
  /*}}}*/
  /*{{{*/
  static const real_t Q_div2_tab_right[31][13] = {
      { FRAC_CONST(0.992246), FRAC_CONST(0.992241), FRAC_CONST(0.992218), FRAC_CONST(0.992128), FRAC_CONST(0.991768), FRAC_CONST(0.990329), FRAC_CONST(0.984615), FRAC_CONST(0.962406), FRAC_CONST(0.882759), FRAC_CONST(0.663212), FRAC_CONST(0.332468), FRAC_CONST(0.111015), FRAC_CONST(0.0302959) },
      { FRAC_CONST(0.984612), FRAC_CONST(0.984601), FRAC_CONST(0.984556), FRAC_CONST(0.984379), FRAC_CONST(0.98367), FRAC_CONST(0.980843), FRAC_CONST(0.969697), FRAC_CONST(0.927536), FRAC_CONST(0.790123), FRAC_CONST(0.496124), FRAC_CONST(0.199377), FRAC_CONST(0.0587695), FRAC_CONST(0.0153809) },
      { FRAC_CONST(0.96969), FRAC_CONST(0.969668), FRAC_CONST(0.969582), FRAC_CONST(0.969238), FRAC_CONST(0.967864), FRAC_CONST(0.962406), FRAC_CONST(0.941176), FRAC_CONST(0.864865), FRAC_CONST(0.653061), FRAC_CONST(0.329897), FRAC_CONST(0.110727), FRAC_CONST(0.0302744), FRAC_CONST(0.00775006) },
      { FRAC_CONST(0.941163), FRAC_CONST(0.941122), FRAC_CONST(0.94096), FRAC_CONST(0.940312), FRAC_CONST(0.937729), FRAC_CONST(0.927536), FRAC_CONST(0.888889), FRAC_CONST(0.761905), FRAC_CONST(0.484848), FRAC_CONST(0.197531), FRAC_CONST(0.0586081), FRAC_CONST(0.0153698), FRAC_CONST(0.0038901) },
      { FRAC_CONST(0.888865), FRAC_CONST(0.888792), FRAC_CONST(0.888503), FRAC_CONST(0.887348), FRAC_CONST(0.882759), FRAC_CONST(0.864865), FRAC_CONST(0.8), FRAC_CONST(0.615385), FRAC_CONST(0.32), FRAC_CONST(0.109589), FRAC_CONST(0.0301887), FRAC_CONST(0.00774443), FRAC_CONST(0.00194884) },
      { FRAC_CONST(0.799961), FRAC_CONST(0.799844), FRAC_CONST(0.799375), FRAC_CONST(0.797508), FRAC_CONST(0.790123), FRAC_CONST(0.761905), FRAC_CONST(0.666667), FRAC_CONST(0.444444), FRAC_CONST(0.190476), FRAC_CONST(0.057971), FRAC_CONST(0.0153257), FRAC_CONST(0.00388727), FRAC_CONST(0.000975372) },
      { FRAC_CONST(0.666612), FRAC_CONST(0.66645), FRAC_CONST(0.6658), FRAC_CONST(0.663212), FRAC_CONST(0.653061), FRAC_CONST(0.615385), FRAC_CONST(0.5), FRAC_CONST(0.285714), FRAC_CONST(0.105263), FRAC_CONST(0.0298507), FRAC_CONST(0.00772201), FRAC_CONST(0.00194742), FRAC_CONST(0.000487924) },
      { FRAC_CONST(0.499939), FRAC_CONST(0.499756), FRAC_CONST(0.499025), FRAC_CONST(0.496124), FRAC_CONST(0.484848), FRAC_CONST(0.444444), FRAC_CONST(0.333333), FRAC_CONST(0.166667), FRAC_CONST(0.0555556), FRAC_CONST(0.0151515), FRAC_CONST(0.00387597), FRAC_CONST(0.000974659), FRAC_CONST(0.000244021) },
      { FRAC_CONST(0.333279), FRAC_CONST(0.333116), FRAC_CONST(0.332468), FRAC_CONST(0.329897), FRAC_CONST(0.32), FRAC_CONST(0.285714), FRAC_CONST(0.2), FRAC_CONST(0.0909091), FRAC_CONST(0.0285714), FRAC_CONST(0.00763359), FRAC_CONST(0.00194175), FRAC_CONST(0.000487567), FRAC_CONST(0.000122026) },
      { FRAC_CONST(0.199961), FRAC_CONST(0.199844), FRAC_CONST(0.199377), FRAC_CONST(0.197531), FRAC_CONST(0.190476), FRAC_CONST(0.166667), FRAC_CONST(0.111111), FRAC_CONST(0.047619), FRAC_CONST(0.0144928), FRAC_CONST(0.00383142), FRAC_CONST(0.000971817), FRAC_CONST(0.000243843), FRAC_CONST(6.10165E-005) },
      { FRAC_CONST(0.111087), FRAC_CONST(0.111015), FRAC_CONST(0.110727), FRAC_CONST(0.109589), FRAC_CONST(0.105263), FRAC_CONST(0.0909091), FRAC_CONST(0.0588235), FRAC_CONST(0.0243902), FRAC_CONST(0.00729927), FRAC_CONST(0.00191939), FRAC_CONST(0.000486145), FRAC_CONST(0.000121936), FRAC_CONST(3.05092E-005) },
      { FRAC_CONST(0.05881), FRAC_CONST(0.0587695), FRAC_CONST(0.0586081), FRAC_CONST(0.057971), FRAC_CONST(0.0555556), FRAC_CONST(0.047619), FRAC_CONST(0.030303), FRAC_CONST(0.0123457), FRAC_CONST(0.003663), FRAC_CONST(0.000960615), FRAC_CONST(0.000243132), FRAC_CONST(6.09719E-005), FRAC_CONST(1.52548E-005) },
      { FRAC_CONST(0.0302959), FRAC_CONST(0.0302744), FRAC_CONST(0.0301887), FRAC_CONST(0.0298507), FRAC_CONST(0.0285714), FRAC_CONST(0.0243902), FRAC_CONST(0.0153846), FRAC_CONST(0.00621118), FRAC_CONST(0.00183486), FRAC_CONST(0.000480538), FRAC_CONST(0.000121581), FRAC_CONST(3.04869E-005), FRAC_CONST(7.62747E-006) },
      { FRAC_CONST(0.0153809), FRAC_CONST(0.0153698), FRAC_CONST(0.0153257), FRAC_CONST(0.0151515), FRAC_CONST(0.0144928), FRAC_CONST(0.0123457), FRAC_CONST(0.00775194), FRAC_CONST(0.00311526), FRAC_CONST(0.000918274), FRAC_CONST(0.000240327), FRAC_CONST(6.0794E-005), FRAC_CONST(1.52437E-005), FRAC_CONST(3.81375E-006) },
      { FRAC_CONST(0.00775006), FRAC_CONST(0.00774443), FRAC_CONST(0.00772201), FRAC_CONST(0.00763359), FRAC_CONST(0.00729927), FRAC_CONST(0.00621118), FRAC_CONST(0.00389105), FRAC_CONST(0.00156006), FRAC_CONST(0.000459348), FRAC_CONST(0.000120178), FRAC_CONST(3.03979E-005), FRAC_CONST(7.62189E-006), FRAC_CONST(1.90688E-006) },
      { FRAC_CONST(0.0038901), FRAC_CONST(0.00388727), FRAC_CONST(0.00387597), FRAC_CONST(0.00383142), FRAC_CONST(0.003663), FRAC_CONST(0.00311526), FRAC_CONST(0.00194932), FRAC_CONST(0.00078064), FRAC_CONST(0.000229727), FRAC_CONST(6.00925E-005), FRAC_CONST(1.51992E-005), FRAC_CONST(3.81096E-006), FRAC_CONST(9.53441E-007) },
      { FRAC_CONST(0.00194884), FRAC_CONST(0.00194742), FRAC_CONST(0.00194175), FRAC_CONST(0.00191939), FRAC_CONST(0.00183486), FRAC_CONST(0.00156006), FRAC_CONST(0.00097561), FRAC_CONST(0.000390472), FRAC_CONST(0.000114877), FRAC_CONST(3.00472E-005), FRAC_CONST(7.59965E-006), FRAC_CONST(1.90548E-006), FRAC_CONST(4.76721E-007) },
      { FRAC_CONST(0.000975372), FRAC_CONST(0.000974659), FRAC_CONST(0.000971817), FRAC_CONST(0.000960615), FRAC_CONST(0.000918274), FRAC_CONST(0.00078064), FRAC_CONST(0.000488043), FRAC_CONST(0.000195274), FRAC_CONST(5.74416E-005), FRAC_CONST(1.50238E-005), FRAC_CONST(3.79984E-006), FRAC_CONST(9.52743E-007), FRAC_CONST(2.3836E-007) },
      { FRAC_CONST(0.000487924), FRAC_CONST(0.000487567), FRAC_CONST(0.000486145), FRAC_CONST(0.000480538), FRAC_CONST(0.000459348), FRAC_CONST(0.000390472), FRAC_CONST(0.000244081), FRAC_CONST(9.76467E-005), FRAC_CONST(2.87216E-005), FRAC_CONST(7.51196E-006), FRAC_CONST(1.89992E-006), FRAC_CONST(4.76372E-007), FRAC_CONST(1.1918E-007) },
      { FRAC_CONST(0.000244021), FRAC_CONST(0.000243843), FRAC_CONST(0.000243132), FRAC_CONST(0.000240327), FRAC_CONST(0.000229727), FRAC_CONST(0.000195274), FRAC_CONST(0.000122055), FRAC_CONST(4.88257E-005), FRAC_CONST(1.4361E-005), FRAC_CONST(3.756E-006), FRAC_CONST(9.49963E-007), FRAC_CONST(2.38186E-007), FRAC_CONST(5.95901E-008) },
      { FRAC_CONST(0.000122026), FRAC_CONST(0.000121936), FRAC_CONST(0.000121581), FRAC_CONST(0.000120178), FRAC_CONST(0.000114877), FRAC_CONST(9.76467E-005), FRAC_CONST(6.10314E-005), FRAC_CONST(2.44135E-005), FRAC_CONST(7.18056E-006), FRAC_CONST(1.878E-006), FRAC_CONST(4.74982E-007), FRAC_CONST(1.19093E-007), FRAC_CONST(2.9795E-008) },
      { FRAC_CONST(6.10165E-005), FRAC_CONST(6.09719E-005), FRAC_CONST(6.0794E-005), FRAC_CONST(6.00925E-005), FRAC_CONST(5.74416E-005), FRAC_CONST(4.88257E-005), FRAC_CONST(3.05166E-005), FRAC_CONST(1.22069E-005), FRAC_CONST(3.59029E-006), FRAC_CONST(9.39002E-007), FRAC_CONST(2.37491E-007), FRAC_CONST(5.95465E-008), FRAC_CONST(1.48975E-008) },
      { FRAC_CONST(3.05092E-005), FRAC_CONST(3.04869E-005), FRAC_CONST(3.03979E-005), FRAC_CONST(3.00472E-005), FRAC_CONST(2.87216E-005), FRAC_CONST(2.44135E-005), FRAC_CONST(1.52586E-005), FRAC_CONST(6.10348E-006), FRAC_CONST(1.79515E-006), FRAC_CONST(4.69501E-007), FRAC_CONST(1.18745E-007), FRAC_CONST(2.97732E-008), FRAC_CONST(7.44876E-009) },
      { FRAC_CONST(1.52548E-005), FRAC_CONST(1.52437E-005), FRAC_CONST(1.51992E-005), FRAC_CONST(1.50238E-005), FRAC_CONST(1.4361E-005), FRAC_CONST(1.22069E-005), FRAC_CONST(7.62934E-006), FRAC_CONST(3.05175E-006), FRAC_CONST(8.97575E-007), FRAC_CONST(2.34751E-007), FRAC_CONST(5.93727E-008), FRAC_CONST(1.48866E-008), FRAC_CONST(3.72438E-009) },
      { FRAC_CONST(7.62747E-006), FRAC_CONST(7.62189E-006), FRAC_CONST(7.59965E-006), FRAC_CONST(7.51196E-006), FRAC_CONST(7.18056E-006), FRAC_CONST(6.10348E-006), FRAC_CONST(3.81468E-006), FRAC_CONST(1.52588E-006), FRAC_CONST(4.48788E-007), FRAC_CONST(1.17375E-007), FRAC_CONST(2.96864E-008), FRAC_CONST(7.44331E-009), FRAC_CONST(1.86219E-009) },
      { FRAC_CONST(3.81375E-006), FRAC_CONST(3.81096E-006), FRAC_CONST(3.79984E-006), FRAC_CONST(3.756E-006), FRAC_CONST(3.59029E-006), FRAC_CONST(3.05175E-006), FRAC_CONST(1.90734E-006), FRAC_CONST(7.62939E-007), FRAC_CONST(2.24394E-007), FRAC_CONST(5.86876E-008), FRAC_CONST(1.48432E-008), FRAC_CONST(3.72166E-009), FRAC_CONST(9.31095E-010) },
      { FRAC_CONST(1.90688E-006), FRAC_CONST(1.90548E-006), FRAC_CONST(1.89992E-006), FRAC_CONST(1.878E-006), FRAC_CONST(1.79515E-006), FRAC_CONST(1.52588E-006), FRAC_CONST(9.53673E-007), FRAC_CONST(3.8147E-007), FRAC_CONST(1.12197E-007), FRAC_CONST(2.93438E-008), FRAC_CONST(7.42159E-009), FRAC_CONST(1.86083E-009), FRAC_CONST(4.65548E-010) },
      { FRAC_CONST(9.53441E-007), FRAC_CONST(9.52743E-007), FRAC_CONST(9.49963E-007), FRAC_CONST(9.39002E-007), FRAC_CONST(8.97575E-007), FRAC_CONST(7.62939E-007), FRAC_CONST(4.76837E-007), FRAC_CONST(1.90735E-007), FRAC_CONST(5.60985E-008), FRAC_CONST(1.46719E-008), FRAC_CONST(3.71079E-009), FRAC_CONST(9.30414E-010), FRAC_CONST(2.32774E-010) },
      { FRAC_CONST(4.76721E-007), FRAC_CONST(4.76372E-007), FRAC_CONST(4.74982E-007), FRAC_CONST(4.69501E-007), FRAC_CONST(4.48788E-007), FRAC_CONST(3.8147E-007), FRAC_CONST(2.38419E-007), FRAC_CONST(9.53674E-008), FRAC_CONST(2.80492E-008), FRAC_CONST(7.33596E-009), FRAC_CONST(1.8554E-009), FRAC_CONST(4.65207E-010), FRAC_CONST(1.16387E-010) },
      { FRAC_CONST(2.3836E-007), FRAC_CONST(2.38186E-007), FRAC_CONST(2.37491E-007), FRAC_CONST(2.34751E-007), FRAC_CONST(2.24394E-007), FRAC_CONST(1.90735E-007), FRAC_CONST(1.19209E-007), FRAC_CONST(4.76837E-008), FRAC_CONST(1.40246E-008), FRAC_CONST(3.66798E-009), FRAC_CONST(9.27699E-010), FRAC_CONST(2.32603E-010), FRAC_CONST(5.81935E-011) },
      { FRAC_CONST(1.1918E-007), FRAC_CONST(1.19093E-007), FRAC_CONST(1.18745E-007), FRAC_CONST(1.17375E-007), FRAC_CONST(1.12197E-007), FRAC_CONST(9.53674E-008), FRAC_CONST(5.96046E-008), FRAC_CONST(2.38419E-008), FRAC_CONST(7.01231E-009), FRAC_CONST(1.83399E-009), FRAC_CONST(4.63849E-010), FRAC_CONST(1.16302E-010), FRAC_CONST(2.90967E-011) }
  };
  /*}}}*/
  /*{{{*/
  /* calculates Q/(1+Q) */
  /* [0..1] */
  static real_t calc_Q_div2(sbr_info *sbr, uint8_t ch, uint8_t m, uint8_t l)
  {
      if (sbr->bs_coupling)
      {
          if ((sbr->Q[0][m][l] < 0 || sbr->Q[0][m][l] > 30) ||
              (sbr->Q[1][m][l] < 0 || sbr->Q[1][m][l] > 24 /* 2*panOffset(1) */))
          {
              return 0;
          } else {
              /* the pan parameter is always even */
              if (ch == 0)
              {
                  return Q_div2_tab_left[sbr->Q[0][m][l]][sbr->Q[1][m][l] >> 1];
              } else {
                  return Q_div2_tab_right[sbr->Q[0][m][l]][sbr->Q[1][m][l] >> 1];
              }
          }
      } else {
          /* no coupling */
          if (sbr->Q[ch][m][l] < 0 || sbr->Q[ch][m][l] > 30)
          {
              return 0;
          } else {
              return Q_div2_tab[sbr->Q[ch][m][l]];
          }
      }
  }
  /*}}}*/
  /*{{{*/
  static const real_t E_deq_tab[64] = {
      64.0f, 128.0f, 256.0f, 512.0f, 1024.0f, 2048.0f, 4096.0f, 8192.0f,
      16384.0f, 32768.0f, 65536.0f, 131072.0f, 262144.0f, 524288.0f, 1.04858E+006f, 2.09715E+006f,
      4.1943E+006f, 8.38861E+006f, 1.67772E+007f, 3.35544E+007f, 6.71089E+007f, 1.34218E+008f, 2.68435E+008f, 5.36871E+008f,
      1.07374E+009f, 2.14748E+009f, 4.29497E+009f, 8.58993E+009f, 1.71799E+010f, 3.43597E+010f, 6.87195E+010f, 1.37439E+011f,
      2.74878E+011f, 5.49756E+011f, 1.09951E+012f, 2.19902E+012f, 4.39805E+012f, 8.79609E+012f, 1.75922E+013f, 3.51844E+013f,
      7.03687E+013f, 1.40737E+014f, 2.81475E+014f, 5.6295E+014f, 1.1259E+015f, 2.2518E+015f, 4.5036E+015f, 9.0072E+015f,
      1.80144E+016f, 3.60288E+016f, 7.20576E+016f, 1.44115E+017f, 2.8823E+017f, 5.76461E+017f, 1.15292E+018f, 2.30584E+018f,
      4.61169E+018f, 9.22337E+018f, 1.84467E+019f, 3.68935E+019f, 7.3787E+019f, 1.47574E+020f, 2.95148E+020f, 5.90296E+020f
  };
  /*}}}*/

  /*{{{*/
  static const int8_t t_huffman_env_1_5dB[120][2] = {
      {   1,   2 },    { -64, -65 },    {   3,   4 },    { -63, -66 },
      {   5,   6 },    { -62, -67 },    {   7,   8 },    { -61, -68 },
      {   9,  10 },    { -60, -69 },    {  11,  12 },    { -59, -70 },
      {  13,  14 },    { -58, -71 },    {  15,  16 },    { -57, -72 },
      {  17,  18 },    { -73, -56 },    {  19,  21 },    { -74,  20 },
      { -55, -75 },    {  22,  26 },    {  23,  24 },    { -54, -76 },
      { -77,  25 },    { -53, -78 },    {  27,  34 },    {  28,  29 },
      { -52, -79 },    {  30,  31 },    { -80, -51 },    {  32,  33 },
      { -83, -82 },    { -81, -50 },    {  35,  57 },    {  36,  40 },
      {  37,  38 },    { -88, -84 },    { -48,  39 },    { -90, -85 },
      {  41,  46 },    {  42,  43 },    { -49, -87 },    {  44,  45 },
      { -89, -86 },    {-124,-123 },    {  47,  50 },    {  48,  49 },
      {-122,-121 },    {-120,-119 },    {  51,  54 },    {  52,  53 },
      {-118,-117 },    {-116,-115 },    {  55,  56 },    {-114,-113 },
      {-112,-111 },    {  58,  89 },    {  59,  74 },    {  60,  67 },
      {  61,  64 },    {  62,  63 },    {-110,-109 },    {-108,-107 },
      {  65,  66 },    {-106,-105 },    {-104,-103 },    {  68,  71 },
      {  69,  70 },    {-102,-101 },    {-100, -99 },    {  72,  73 },
      { -98, -97 },    { -96, -95 },    {  75,  82 },    {  76,  79 },
      {  77,  78 },    { -94, -93 },    { -92, -91 },    {  80,  81 },
      { -47, -46 },    { -45, -44 },    {  83,  86 },    {  84,  85 },
      { -43, -42 },    { -41, -40 },    {  87,  88 },    { -39, -38 },
      { -37, -36 },    {  90, 105 },    {  91,  98 },    {  92,  95 },
      {  93,  94 },    { -35, -34 },    { -33, -32 },    {  96,  97 },
      { -31, -30 },    { -29, -28 },    {  99, 102 },    { 100, 101 },
      { -27, -26 },    { -25, -24 },    { 103, 104 },    { -23, -22 },
      { -21, -20 },    { 106, 113 },    { 107, 110 },    { 108, 109 },
      { -19, -18 },    { -17, -16 },    { 111, 112 },    { -15, -14 },
      { -13, -12 },    { 114, 117 },    { 115, 116 },    { -11, -10 },
      {  -9,  -8 },    { 118, 119 },    {  -7,  -6 },    {  -5,  -4 }
  };
  /*}}}*/
  /*{{{*/
  static const int8_t f_huffman_env_1_5dB[120][2] = {
      {   1,   2 },    { -64, -65 },    {   3,   4 },    { -63, -66 },
      {   5,   6 },    { -67, -62 },    {   7,   8 },    { -68, -61 },
      {   9,  10 },    { -69, -60 },    {  11,  13 },    { -70,  12 },
      { -59, -71 },    {  14,  16 },    { -58,  15 },    { -72, -57 },
      {  17,  19 },    { -73,  18 },    { -56, -74 },    {  20,  23 },
      {  21,  22 },    { -55, -75 },    { -54, -53 },    {  24,  27 },
      {  25,  26 },    { -76, -52 },    { -77, -51 },    {  28,  31 },
      {  29,  30 },    { -50, -78 },    { -79, -49 },    {  32,  36 },
      {  33,  34 },    { -48, -47 },    { -80,  35 },    { -81, -82 },
      {  37,  47 },    {  38,  41 },    {  39,  40 },    { -83, -46 },
      { -45, -84 },    {  42,  44 },    { -85,  43 },    { -44, -43 },
      {  45,  46 },    { -88, -87 },    { -86, -90 },    {  48,  66 },
      {  49,  56 },    {  50,  53 },    {  51,  52 },    { -92, -42 },
      { -41, -39 },    {  54,  55 },    {-105, -89 },    { -38, -37 },
      {  57,  60 },    {  58,  59 },    { -94, -91 },    { -40, -36 },
      {  61,  63 },    { -20,  62 },    {-115,-110 },    {  64,  65 },
      {-108,-107 },    {-101, -97 },    {  67,  89 },    {  68,  75 },
      {  69,  72 },    {  70,  71 },    { -95, -93 },    { -34, -27 },
      {  73,  74 },    { -22, -17 },    { -16,-124 },    {  76,  82 },
      {  77,  79 },    {-123,  78 },    {-122,-121 },    {  80,  81 },
      {-120,-119 },    {-118,-117 },    {  83,  86 },    {  84,  85 },
      {-116,-114 },    {-113,-112 },    {  87,  88 },    {-111,-109 },
      {-106,-104 },    {  90, 105 },    {  91,  98 },    {  92,  95 },
      {  93,  94 },    {-103,-102 },    {-100, -99 },    {  96,  97 },
      { -98, -96 },    { -35, -33 },    {  99, 102 },    { 100, 101 },
      { -32, -31 },    { -30, -29 },    { 103, 104 },    { -28, -26 },
      { -25, -24 },    { 106, 113 },    { 107, 110 },    { 108, 109 },
      { -23, -21 },    { -19, -18 },    { 111, 112 },    { -15, -14 },
      { -13, -12 },    { 114, 117 },    { 115, 116 },    { -11, -10 },
      {  -9,  -8 },    { 118, 119 },    {  -7,  -6 },    {  -5,  -4 }
  };
  /*}}}*/
  /*{{{*/
  static const int8_t t_huffman_env_bal_1_5dB[48][2] = {
      { -64,   1 },    { -63,   2 },    { -65,   3 },    { -62,   4 },
      { -66,   5 },    { -61,   6 },    { -67,   7 },    { -60,   8 },
      { -68,   9 },    {  10,  11 },    { -69, -59 },    {  12,  13 },
      { -70, -58 },    {  14,  28 },    {  15,  21 },    {  16,  18 },
      { -57,  17 },    { -71, -56 },    {  19,  20 },    { -88, -87 },
      { -86, -85 },    {  22,  25 },    {  23,  24 },    { -84, -83 },
      { -82, -81 },    {  26,  27 },    { -80, -79 },    { -78, -77 },
      {  29,  36 },    {  30,  33 },    {  31,  32 },    { -76, -75 },
      { -74, -73 },    {  34,  35 },    { -72, -55 },    { -54, -53 },
      {  37,  41 },    {  38,  39 },    { -52, -51 },    { -50,  40 },
      { -49, -48 },    {  42,  45 },    {  43,  44 },    { -47, -46 },
      { -45, -44 },    {  46,  47 },    { -43, -42 },    { -41, -40 }
  };
  /*}}}*/
  /*{{{*/
  static const int8_t f_huffman_env_bal_1_5dB[48][2] = {
      { -64,   1 },    { -65,   2 },    { -63,   3 },    { -66,   4 },
      { -62,   5 },    { -61,   6 },    { -67,   7 },    { -68,   8 },
      { -60,   9 },    {  10,  11 },    { -69, -59 },    { -70,  12 },
      { -58,  13 },    {  14,  17 },    { -71,  15 },    { -57,  16 },
      { -56, -73 },    {  18,  32 },    {  19,  25 },    {  20,  22 },
      { -72,  21 },    { -88, -87 },    {  23,  24 },    { -86, -85 },
      { -84, -83 },    {  26,  29 },    {  27,  28 },    { -82, -81 },
      { -80, -79 },    {  30,  31 },    { -78, -77 },    { -76, -75 },
      {  33,  40 },    {  34,  37 },    {  35,  36 },    { -74, -55 },
      { -54, -53 },    {  38,  39 },    { -52, -51 },    { -50, -49 },
      {  41,  44 },    {  42,  43 },    { -48, -47 },    { -46, -45 },
      {  45,  46 },    { -44, -43 },    { -42,  47 },    { -41, -40 }
  };
  /*}}}*/
  /*{{{*/
  static const int8_t t_huffman_env_3_0dB[62][2] = {
      { -64,   1 },    { -65,   2 },    { -63,   3 },    { -66,   4 },
      { -62,   5 },    { -67,   6 },    { -61,   7 },    { -68,   8 },
      { -60,   9 },    {  10,  11 },    { -69, -59 },    {  12,  14 },
      { -70,  13 },    { -71, -58 },    {  15,  18 },    {  16,  17 },
      { -72, -57 },    { -73, -74 },    {  19,  22 },    { -56,  20 },
      { -55,  21 },    { -54, -77 },    {  23,  31 },    {  24,  25 },
      { -75, -76 },    {  26,  27 },    { -78, -53 },    {  28,  29 },
      { -52, -95 },    { -94,  30 },    { -93, -92 },    {  32,  47 },
      {  33,  40 },    {  34,  37 },    {  35,  36 },    { -91, -90 },
      { -89, -88 },    {  38,  39 },    { -87, -86 },    { -85, -84 },
      {  41,  44 },    {  42,  43 },    { -83, -82 },    { -81, -80 },
      {  45,  46 },    { -79, -51 },    { -50, -49 },    {  48,  55 },
      {  49,  52 },    {  50,  51 },    { -48, -47 },    { -46, -45 },
      {  53,  54 },    { -44, -43 },    { -42, -41 },    {  56,  59 },
      {  57,  58 },    { -40, -39 },    { -38, -37 },    {  60,  61 },
      { -36, -35 },    { -34, -33 }
  };
  /*}}}*/
  /*{{{*/
  static const int8_t f_huffman_env_3_0dB[62][2] = {
      { -64,   1 },    { -65,   2 },    { -63,   3 },    { -66,   4 },
      { -62,   5 },    { -67,   6 },    {   7,   8 },    { -61, -68 },
      {   9,  10 },    { -60, -69 },    {  11,  12 },    { -59, -70 },
      {  13,  14 },    { -58, -71 },    {  15,  16 },    { -57, -72 },
      {  17,  19 },    { -56,  18 },    { -55, -73 },    {  20,  24 },
      {  21,  22 },    { -74, -54 },    { -53,  23 },    { -75, -76 },
      {  25,  30 },    {  26,  27 },    { -52, -51 },    {  28,  29 },
      { -77, -79 },    { -50, -49 },    {  31,  39 },    {  32,  35 },
      {  33,  34 },    { -78, -46 },    { -82, -88 },    {  36,  37 },
      { -83, -48 },    { -47,  38 },    { -86, -85 },    {  40,  47 },
      {  41,  44 },    {  42,  43 },    { -80, -44 },    { -43, -42 },
      {  45,  46 },    { -39, -87 },    { -84, -40 },    {  48,  55 },
      {  49,  52 },    {  50,  51 },    { -95, -94 },    { -93, -92 },
      {  53,  54 },    { -91, -90 },    { -89, -81 },    {  56,  59 },
      {  57,  58 },    { -45, -41 },    { -38, -37 },    {  60,  61 },
      { -36, -35 },    { -34, -33 }
  };
  /*}}}*/
  /*{{{*/
  static const int8_t t_huffman_env_bal_3_0dB[24][2] = {
      { -64,   1 },    { -63,   2 },    { -65,   3 },    { -66,   4 },
      { -62,   5 },    { -61,   6 },    { -67,   7 },    { -68,   8 },
      { -60,   9 },    {  10,  16 },    {  11,  13 },    { -69,  12 },
      { -76, -75 },    {  14,  15 },    { -74, -73 },    { -72, -71 },
      {  17,  20 },    {  18,  19 },    { -70, -59 },    { -58, -57 },
      {  21,  22 },    { -56, -55 },    { -54,  23 },    { -53, -52 }
  };
  /*}}}*/
  /*{{{*/
  static const int8_t f_huffman_env_bal_3_0dB[24][2] = {
      { -64,   1 },    { -65,   2 },    { -63,   3 },    { -66,   4 },
      { -62,   5 },    { -61,   6 },    { -67,   7 },    { -68,   8 },
      { -60,   9 },    {  10,  13 },    { -69,  11 },    { -59,  12 },
      { -58, -76 },    {  14,  17 },    {  15,  16 },    { -75, -74 },
      { -73, -72 },    {  18,  21 },    {  19,  20 },    { -71, -70 },
      { -57, -56 },    {  22,  23 },    { -55, -54 },    { -53, -52 }
  };
  /*}}}*/
  /*{{{*/
  static const int8_t t_huffman_noise_3_0dB[62][2] = {
      { -64,   1 },    { -63,   2 },    { -65,   3 },    { -66,   4 },
      { -62,   5 },    { -67,   6 },    {   7,   8 },    { -61, -68 },
      {   9,  30 },    {  10,  15 },    { -60,  11 },    { -69,  12 },
      {  13,  14 },    { -59, -53 },    { -95, -94 },    {  16,  23 },
      {  17,  20 },    {  18,  19 },    { -93, -92 },    { -91, -90 },
      {  21,  22 },    { -89, -88 },    { -87, -86 },    {  24,  27 },
      {  25,  26 },    { -85, -84 },    { -83, -82 },    {  28,  29 },
      { -81, -80 },    { -79, -78 },    {  31,  46 },    {  32,  39 },
      {  33,  36 },    {  34,  35 },    { -77, -76 },    { -75, -74 },
      {  37,  38 },    { -73, -72 },    { -71, -70 },    {  40,  43 },
      {  41,  42 },    { -58, -57 },    { -56, -55 },    {  44,  45 },
      { -54, -52 },    { -51, -50 },    {  47,  54 },    {  48,  51 },
      {  49,  50 },    { -49, -48 },    { -47, -46 },    {  52,  53 },
      { -45, -44 },    { -43, -42 },    {  55,  58 },    {  56,  57 },
      { -41, -40 },    { -39, -38 },    {  59,  60 },    { -37, -36 },
      { -35,  61 },    { -34, -33 }
  };
  /*}}}*/
  /*{{{*/
  static const int8_t t_huffman_noise_bal_3_0dB[24][2] = {
      { -64,   1 },    { -65,   2 },    { -63,   3 },    {   4,   9 },
      { -66,   5 },    { -62,   6 },    {   7,   8 },    { -76, -75 },
      { -74, -73 },    {  10,  17 },    {  11,  14 },    {  12,  13 },
      { -72, -71 },    { -70, -69 },    {  15,  16 },    { -68, -67 },
      { -61, -60 },    {  18,  21 },    {  19,  20 },    { -59, -58 },
      { -57, -56 },    {  22,  23 },    { -55, -54 },    { -53, -52 }
  };
  /*}}}*/

  /*{{{*/
  static uint8_t sbr_save_prev_data (sbr_info *sbr, uint8_t ch)
  {
      uint8_t i;

      /* save data for next frame */
      sbr->kx_prev = sbr->kx;
      sbr->M_prev = sbr->M;
      sbr->bsco_prev = sbr->bsco;

      sbr->L_E_prev[ch] = sbr->L_E[ch];

      /* sbr->L_E[ch] can become 0 on files with bit errors */
      if (sbr->L_E[ch] <= 0)
          return 19;

      sbr->f_prev[ch] = sbr->f[ch][sbr->L_E[ch] - 1];
      for (i = 0; i < MAX_M; i++)
      {
          sbr->E_prev[ch][i] = sbr->E[ch][i][sbr->L_E[ch] - 1];
          sbr->Q_prev[ch][i] = sbr->Q[ch][i][sbr->L_Q[ch] - 1];
      }

      for (i = 0; i < MAX_M; i++)
      {
          sbr->bs_add_harmonic_prev[ch][i] = sbr->bs_add_harmonic[ch][i];
      }
      sbr->bs_add_harmonic_flag_prev[ch] = sbr->bs_add_harmonic_flag[ch];

      if (sbr->l_A[ch] == sbr->L_E[ch])
          sbr->prevEnvIsShort[ch] = 0;
      else
          sbr->prevEnvIsShort[ch] = -1;

      return 0;
  }
  /*}}}*/
  /*{{{*/
  static void sbr_save_matrix (sbr_info *sbr, uint8_t ch)
  {
      uint8_t i;

      for (i = 0; i < sbr->tHFGen; i++)
      {
          memmove(sbr->Xsbr[ch][i], sbr->Xsbr[ch][i+sbr->numTimeSlotsRate], 64 * sizeof(qmf_t));
      }
      for (i = sbr->tHFGen; i < MAX_NTSRHFG; i++)
      {
          memset(sbr->Xsbr[ch][i], 0, 64 * sizeof(qmf_t));
      }
  }
  /*}}}*/
  /*{{{*/
  static uint8_t sbr_process_channel (sbr_info *sbr, real_t *channel_buf, qmf_t X[MAX_NTSR][64],
                                     uint8_t ch, uint8_t dont_process,
                                     const uint8_t downSampledSBR)
  {
      int16_t k, l;
      uint8_t ret = 0;

  #ifdef SBR_LOW_POWER
      ALIGN real_t deg[64];
  #endif
          sbr->bsco = 0;


  //#define PRE_QMF_PRINT
  #ifdef PRE_QMF_PRINT
      {
          int i;
          for (i = 0; i < 1024; i++)
          {
              printf("%d\n", channel_buf[i]);
          }
      }
  #endif


      /* subband analysis */
      if (dont_process)
          sbr_qmf_analysis_32(sbr, sbr->qmfa[ch], channel_buf, sbr->Xsbr[ch], sbr->tHFGen, 32);
      else
          sbr_qmf_analysis_32(sbr, sbr->qmfa[ch], channel_buf, sbr->Xsbr[ch], sbr->tHFGen, sbr->kx);

      if (!dont_process)
      {
  #if 1
          /* insert high frequencies here */
          /* hf generation using patching */
          hf_generation(sbr, sbr->Xsbr[ch], sbr->Xsbr[ch]
  #ifdef SBR_LOW_POWER
              ,deg
  #endif
              ,ch);
  #endif

  #if 0 //def SBR_LOW_POWER
          for (l = sbr->t_E[ch][0]; l < sbr->t_E[ch][sbr->L_E[ch]]; l++)
          {
              for (k = 0; k < sbr->kx; k++)
              {
                  QMF_RE(sbr->Xsbr[ch][sbr->tHFAdj + l][k]) = 0;
              }
          }
  #endif

  #if 1
          /* hf adjustment */
          ret = hf_adjustment(sbr, sbr->Xsbr[ch]
  #ifdef SBR_LOW_POWER
              ,deg
  #endif
              ,ch);
  #endif
          if (ret > 0)
          {
              dont_process = 1;
          }
      }

      if ((sbr->just_seeked != 0) || dont_process)
      {
          for (l = 0; l < sbr->numTimeSlotsRate; l++)
          {
              for (k = 0; k < 32; k++)
              {
                  QMF_RE(X[l][k]) = QMF_RE(sbr->Xsbr[ch][l + sbr->tHFAdj][k]);
  #ifndef SBR_LOW_POWER
                  QMF_IM(X[l][k]) = QMF_IM(sbr->Xsbr[ch][l + sbr->tHFAdj][k]);
  #endif
              }
              for (k = 32; k < 64; k++)
              {
                  QMF_RE(X[l][k]) = 0;
  #ifndef SBR_LOW_POWER
                  QMF_IM(X[l][k]) = 0;
  #endif
              }
          }
      } else {
          for (l = 0; l < sbr->numTimeSlotsRate; l++)
          {
              uint8_t kx_band, M_band, bsco_band;

              if (l < sbr->t_E[ch][0])
              {
                  kx_band = sbr->kx_prev;
                  M_band = sbr->M_prev;
                  bsco_band = sbr->bsco_prev;
              } else {
                  kx_band = sbr->kx;
                  M_band = sbr->M;
                  bsco_band = sbr->bsco;
              }

  #ifndef SBR_LOW_POWER
              for (k = 0; k < kx_band + bsco_band; k++)
              {
                  QMF_RE(X[l][k]) = QMF_RE(sbr->Xsbr[ch][l + sbr->tHFAdj][k]);
                  QMF_IM(X[l][k]) = QMF_IM(sbr->Xsbr[ch][l + sbr->tHFAdj][k]);
              }
              for (k = kx_band + bsco_band; k < kx_band + M_band; k++)
              {
                  QMF_RE(X[l][k]) = QMF_RE(sbr->Xsbr[ch][l + sbr->tHFAdj][k]);
                  QMF_IM(X[l][k]) = QMF_IM(sbr->Xsbr[ch][l + sbr->tHFAdj][k]);
              }
              for (k = max(kx_band + bsco_band, kx_band + M_band); k < 64; k++)
              {
                  QMF_RE(X[l][k]) = 0;
                  QMF_IM(X[l][k]) = 0;
              }
  #else
              for (k = 0; k < kx_band + bsco_band; k++)
              {
                  QMF_RE(X[l][k]) = QMF_RE(sbr->Xsbr[ch][l + sbr->tHFAdj][k]);
              }
              for (k = kx_band + bsco_band; k < min(kx_band + M_band, 63); k++)
              {
                  QMF_RE(X[l][k]) = QMF_RE(sbr->Xsbr[ch][l + sbr->tHFAdj][k]);
              }
              for (k = max(kx_band + bsco_band, kx_band + M_band); k < 64; k++)
              {
                  QMF_RE(X[l][k]) = 0;
              }
              QMF_RE(X[l][kx_band - 1 + bsco_band]) +=
                  QMF_RE(sbr->Xsbr[ch][l + sbr->tHFAdj][kx_band - 1 + bsco_band]);
  #endif
          }
      }

      return ret;
  }
  /*}}}*/

  /*{{{*/
  static int longcmp(const void *a, const void *b)
  {
      return ((int)(*(int32_t*)a - *(int32_t*)b));
  }
  /*}}}*/
  /*{{{*/
  /*
     This function finds the number of bands using this formula:
      bands * log(a1/a0)/log(2.0) + 0.5
  */
  static int32_t find_bands(uint8_t warp, uint8_t bands, uint8_t a0, uint8_t a1)
  {
      real_t div = (real_t)log(2.0);
      if (warp) div *= (real_t)1.3;

      return (int32_t)(bands * log((float)a1/(float)a0)/div + 0.5);
  }
  /*}}}*/
  /*{{{*/
  static real_t find_initial_power(uint8_t bands, uint8_t a0, uint8_t a1)
  {
      return (real_t)pow((real_t)a1/(real_t)a0, 1.0/(real_t)bands);
  }
  /*}}}*/

  /*{{{*/
  /* calculate the start QMF channel for the master frequency band table */
  /* parameter is also called k0 */
  uint8_t qmf_start_channel(uint8_t bs_start_freq, uint8_t bs_samplerate_mode,
                             uint32_t sample_rate)
  {
      static const uint8_t startMinTable[12] = { 7, 7, 10, 11, 12, 16, 16,
          17, 24, 32, 35, 48 };
      static const uint8_t offsetIndexTable[12] = { 5, 5, 4, 4, 4, 3, 2, 1, 0,
          6, 6, 6 };
      static const int8_t offset[7][16] = {
          { -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7 },
          { -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 13 },
          { -5, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 13, 16 },
          { -6, -4, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 13, 16 },
          { -4, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 13, 16, 20 },
          { -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 13, 16, 20, 24 },
          { 0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 13, 16, 20, 24, 28, 33 }
      };
      uint8_t startMin = startMinTable[get_sr_index(sample_rate)];
      uint8_t offsetIndex = offsetIndexTable[get_sr_index(sample_rate)];

  #if 0 /* replaced with table (startMinTable) */
      if (sample_rate >= 64000)
      {
          startMin = (uint8_t)((5000.*128.)/(float)sample_rate + 0.5);
      } else if (sample_rate < 32000) {
          startMin = (uint8_t)((3000.*128.)/(float)sample_rate + 0.5);
      } else {
          startMin = (uint8_t)((4000.*128.)/(float)sample_rate + 0.5);
      }
  #endif

      if (bs_samplerate_mode)
      {
          return startMin + offset[offsetIndex][bs_start_freq];

  #if 0 /* replaced by offsetIndexTable */
          switch (sample_rate)
          {
          case 16000:
              return startMin + offset[0][bs_start_freq];
          case 22050:
              return startMin + offset[1][bs_start_freq];
          case 24000:
              return startMin + offset[2][bs_start_freq];
          case 32000:
              return startMin + offset[3][bs_start_freq];
          default:
              if (sample_rate > 64000)
              {
                  return startMin + offset[5][bs_start_freq];
              } else { /* 44100 <= sample_rate <= 64000 */
                  return startMin + offset[4][bs_start_freq];
              }
          }
  #endif
      } else {
          return startMin + offset[6][bs_start_freq];
      }
  }
  /*}}}*/
  /*{{{*/
  /* calculate the stop QMF channel for the master frequency band table */
  /* parameter is also called k2 */
  uint8_t qmf_stop_channel(uint8_t bs_stop_freq, uint32_t sample_rate,
                            uint8_t k0)
  {
      if (bs_stop_freq == 15)
      {
          return min(64, k0 * 3);
      } else if (bs_stop_freq == 14) {
          return min(64, k0 * 2);
      } else {
          static const uint8_t stopMinTable[12] = { 13, 15, 20, 21, 23,
              32, 32, 35, 48, 64, 70, 96 };
          static const int8_t offset[12][14] = {
              { 0, 2, 4, 6, 8, 11, 14, 18, 22, 26, 31, 37, 44, 51 },
              { 0, 2, 4, 6, 8, 11, 14, 18, 22, 26, 31, 36, 42, 49 },
              { 0, 2, 4, 6, 8, 11, 14, 17, 21, 25, 29, 34, 39, 44 },
              { 0, 2, 4, 6, 8, 11, 14, 17, 20, 24, 28, 33, 38, 43 },
              { 0, 2, 4, 6, 8, 11, 14, 17, 20, 24, 28, 32, 36, 41 },
              { 0, 2, 4, 6, 8, 10, 12, 14, 17, 20, 23, 26, 29, 32 },
              { 0, 2, 4, 6, 8, 10, 12, 14, 17, 20, 23, 26, 29, 32 },
              { 0, 1, 3, 5, 7, 9, 11, 13, 15, 17, 20, 23, 26, 29 },
              { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 16 },
              { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
              { 0, -1, -2, -3, -4, -5, -6, -6, -6, -6, -6, -6, -6, -6 },
              { 0, -3, -6, -9, -12, -15, -18, -20, -22, -24, -26, -28, -30, -32 }
          };
  #if 0
          uint8_t i;
          int32_t stopDk[13], stopDk_t[14], k2;
  #endif
          uint8_t stopMin = stopMinTable[get_sr_index(sample_rate)];

  #if 0 /* replaced by table lookup */
          if (sample_rate >= 64000)
          {
              stopMin = (uint8_t)((10000.*128.)/(float)sample_rate + 0.5);
          } else if (sample_rate < 32000) {
              stopMin = (uint8_t)((6000.*128.)/(float)sample_rate + 0.5);
          } else {
              stopMin = (uint8_t)((8000.*128.)/(float)sample_rate + 0.5);
          }
  #endif

  #if 0 /* replaced by table lookup */
          /* diverging power series */
          for (i = 0; i <= 13; i++)
          {
              stopDk_t[i] = (int32_t)(stopMin*pow(64.0/stopMin, i/13.0) + 0.5);
          }
          for (i = 0; i < 13; i++)
          {
              stopDk[i] = stopDk_t[i+1] - stopDk_t[i];
          }

          /* needed? */
          qsort(stopDk, 13, sizeof(stopDk[0]), longcmp);

          k2 = stopMin;
          for (i = 0; i < bs_stop_freq; i++)
          {
              k2 += stopDk[i];
          }
          return min(64, k2);
  #endif
          /* bs_stop_freq <= 13 */
          return min(64, stopMin + offset[get_sr_index(sample_rate)][min(bs_stop_freq, 13)]);
      }

      return 0;
  }
  /*}}}*/

  /*{{{*/
  /* calculate the master frequency table from k0, k2, bs_freq_scale
     and bs_alter_scale

     version for bs_freq_scale = 0
  */
  uint8_t master_frequency_table_fs0(sbr_info *sbr, uint8_t k0, uint8_t k2,
                                     uint8_t bs_alter_scale)
  {
      int8_t incr;
      uint8_t k;
      uint8_t dk;
      uint32_t nrBands, k2Achieved;
      int32_t k2Diff, vDk[64] = {0};

      /* mft only defined for k2 > k0 */
      if (k2 <= k0)
      {
          sbr->N_master = 0;
          return 1;
      }

      dk = bs_alter_scale ? 2 : 1;

  #if 0 /* replaced by float-less design */
      nrBands = 2 * (int32_t)((float)(k2-k0)/(dk*2) + (-1+dk)/2.0f);
  #else
      if (bs_alter_scale)
      {
          nrBands = (((k2-k0+2)>>2)<<1);
      } else {
          nrBands = (((k2-k0)>>1)<<1);
      }
  #endif
      nrBands = min(nrBands, 63);
      if (nrBands <= 0)
          return 1;

      k2Achieved = k0 + nrBands * dk;
      k2Diff = k2 - k2Achieved;
      for (k = 0; k < nrBands; k++)
          vDk[k] = dk;

      if (k2Diff)
      {
          incr = (k2Diff > 0) ? -1 : 1;
          k = (uint8_t) ((k2Diff > 0) ? (nrBands-1) : 0);

          while (k2Diff != 0)
          {
              vDk[k] -= incr;
              k += incr;
              k2Diff += incr;
          }
      }

      sbr->f_master[0] = k0;
      for (k = 1; k <= nrBands; k++)
          sbr->f_master[k] = (uint8_t)(sbr->f_master[k-1] + vDk[k-1]);

      sbr->N_master = (uint8_t)nrBands;
      sbr->N_master = (min(sbr->N_master, 64));

  #if 0
      printf("f_master[%d]: ", nrBands);
      for (k = 0; k <= nrBands; k++)
      {
          printf("%d ", sbr->f_master[k]);
      }
      printf("\n");
  #endif

      return 0;
  }
  /*}}}*/
  /*{{{*/
  /*
     version for bs_freq_scale > 0
  */
  uint8_t master_frequency_table(sbr_info *sbr, uint8_t k0, uint8_t k2,
                                 uint8_t bs_freq_scale, uint8_t bs_alter_scale)
  {
      uint8_t k, bands, twoRegions;
      uint8_t k1;
      uint8_t nrBand0, nrBand1;
      int32_t vDk0[64] = {0}, vDk1[64] = {0};
      int32_t vk0[64] = {0}, vk1[64] = {0};
      uint8_t temp1[] = { 6, 5, 4 };
      real_t q, qk;
      int32_t A_1;

      /* mft only defined for k2 > k0 */
      if (k2 <= k0)
      {
          sbr->N_master = 0;
          return 1;
      }

      bands = temp1[bs_freq_scale-1];

      if ((float)k2/(float)k0 > 2.2449)
      {
          twoRegions = 1;
          k1 = k0 << 1;
      } else {
          twoRegions = 0;
          k1 = k2;
      }

      nrBand0 = (uint8_t)(2 * find_bands(0, bands, k0, k1));
      nrBand0 = min(nrBand0, 63);
      if (nrBand0 <= 0)
          return 1;

      q = find_initial_power(nrBand0, k0, k1);
      qk = REAL_CONST(k0);
      A_1 = (int32_t)(qk + .5);
      for (k = 0; k <= nrBand0; k++)
      {
          int32_t A_0 = A_1;
          qk *= q;
          A_1 = (int32_t)(qk + 0.5);
          vDk0[k] = A_1 - A_0;
      }

      /* needed? */
      qsort(vDk0, nrBand0, sizeof(vDk0[0]), longcmp);

      vk0[0] = k0;
      for (k = 1; k <= nrBand0; k++)
      {
          vk0[k] = vk0[k-1] + vDk0[k-1];
          if (vDk0[k-1] == 0)
              return 1;
      }

      if (!twoRegions)
      {
          for (k = 0; k <= nrBand0; k++)
              sbr->f_master[k] = (uint8_t) vk0[k];

          sbr->N_master = nrBand0;
          sbr->N_master = min(sbr->N_master, 64);
          return 0;
      }

      nrBand1 = (uint8_t)(2 * find_bands(1 /* warped */, bands, k1, k2));
      nrBand1 = min(nrBand1, 63);

      q = find_initial_power(nrBand1, k1, k2);
      qk = REAL_CONST(k1);
      A_1 = (int32_t)(qk + .5);
      for (k = 0; k <= nrBand1 - 1; k++)
      {
          int32_t A_0 = A_1;
          qk *= q;
          A_1 = (int32_t)(qk + 0.5);
          vDk1[k] = A_1 - A_0;
      }

      if (vDk1[0] < vDk0[nrBand0 - 1])
      {
          int32_t change;

          /* needed? */
          qsort(vDk1, nrBand1 + 1, sizeof(vDk1[0]), longcmp);
          change = vDk0[nrBand0 - 1] - vDk1[0];
          vDk1[0] = vDk0[nrBand0 - 1];
          vDk1[nrBand1 - 1] = vDk1[nrBand1 - 1] - change;
      }

      /* needed? */
      qsort(vDk1, nrBand1, sizeof(vDk1[0]), longcmp);
      vk1[0] = k1;
      for (k = 1; k <= nrBand1; k++)
      {
          vk1[k] = vk1[k-1] + vDk1[k-1];
          if (vDk1[k-1] == 0)
              return 1;
      }

      sbr->N_master = nrBand0 + nrBand1;
      sbr->N_master = min(sbr->N_master, 64);
      for (k = 0; k <= nrBand0; k++)
      {
          sbr->f_master[k] =  (uint8_t) vk0[k];
      }
      for (k = nrBand0 + 1; k <= sbr->N_master; k++)
      {
          sbr->f_master[k] = (uint8_t) vk1[k - nrBand0];
      }

  #if 0
      printf("f_master[%d]: ", sbr->N_master);
      for (k = 0; k <= sbr->N_master; k++)
      {
          printf("%d ", sbr->f_master[k]);
      }
      printf("\n");
  #endif

      return 0;
  }
  /*}}}*/

  /*{{{*/
  /* calculate the derived frequency border tables from f_master */
  uint8_t derived_frequency_table(sbr_info *sbr, uint8_t bs_xover_band,
                                  uint8_t k2)
  {
      uint8_t k, i;
      uint32_t minus;

      /* The following relation shall be satisfied: bs_xover_band < N_Master */
      if (sbr->N_master <= bs_xover_band)
          return 1;

      sbr->N_high = sbr->N_master - bs_xover_band;
      sbr->N_low = (sbr->N_high>>1) + (sbr->N_high - ((sbr->N_high>>1)<<1));

      sbr->n[0] = sbr->N_low;
      sbr->n[1] = sbr->N_high;

      for (k = 0; k <= sbr->N_high; k++)
      {
          sbr->f_table_res[HI_RES][k] = sbr->f_master[k + bs_xover_band];
      }

      sbr->M = sbr->f_table_res[HI_RES][sbr->N_high] - sbr->f_table_res[HI_RES][0];
      sbr->kx = sbr->f_table_res[HI_RES][0];
      if (sbr->kx > 32)
          return 1;
      if (sbr->kx + sbr->M > 64)
          return 1;

      minus = (sbr->N_high & 1) ? 1 : 0;

      for (k = 0; k <= sbr->N_low; k++)
      {
          if (k == 0)
              i = 0;
          else
              i = (uint8_t)(2*k - minus);
          sbr->f_table_res[LO_RES][k] = sbr->f_table_res[HI_RES][i];
      }

  #if 0
      printf("bs_freq_scale: %d\n", sbr->bs_freq_scale);
      printf("bs_limiter_bands: %d\n", sbr->bs_limiter_bands);
      printf("f_table_res[HI_RES][%d]: ", sbr->N_high);
      for (k = 0; k <= sbr->N_high; k++)
      {
          printf("%d ", sbr->f_table_res[HI_RES][k]);
      }
      printf("\n");
  #endif
  #if 0
      printf("f_table_res[LO_RES][%d]: ", sbr->N_low);
      for (k = 0; k <= sbr->N_low; k++)
      {
          printf("%d ", sbr->f_table_res[LO_RES][k]);
      }
      printf("\n");
  #endif

      sbr->N_Q = 0;
      if (sbr->bs_noise_bands == 0)
      {
          sbr->N_Q = 1;
      } else {
  #if 0
          sbr->N_Q = max(1, (int32_t)(sbr->bs_noise_bands*(log(k2/(float)sbr->kx)/log(2.0)) + 0.5));
  #else
          sbr->N_Q = (uint8_t)(max(1, find_bands(0, sbr->bs_noise_bands, sbr->kx, k2)));
  #endif
          sbr->N_Q = min(5, sbr->N_Q);
      }

      for (k = 0; k <= sbr->N_Q; k++)
      {
          if (k == 0)
          {
              i = 0;
          } else {
              /* i = i + (int32_t)((sbr->N_low - i)/(sbr->N_Q + 1 - k)); */
              i = i + (sbr->N_low - i)/(sbr->N_Q + 1 - k);
          }
          sbr->f_table_noise[k] = sbr->f_table_res[LO_RES][i];
      }

      /* build table for mapping k to g in hf patching */
      for (k = 0; k < 64; k++)
      {
          uint8_t g;
          for (g = 0; g < sbr->N_Q; g++)
          {
              if ((sbr->f_table_noise[g] <= k) &&
                  (k < sbr->f_table_noise[g+1]))
              {
                  sbr->table_map_k_to_g[k] = g;
                  break;
              }
          }
      }

  #if 0
      printf("f_table_noise[%d]: ", sbr->N_Q);
      for (k = 0; k <= sbr->N_Q; k++)
      {
          printf("%d ", sbr->f_table_noise[k] - sbr->kx);
      }
      printf("\n");
  #endif

      return 0;
  }
  /*}}}*/
  /*{{{*/
  /* TODO: blegh, ugly */
  /* Modified to calculate for all possible bs_limiter_bands always
   * This reduces the number calls to this functions needed (now only on
   * header reset)
   */
  void limiter_frequency_table(sbr_info *sbr)
  {
  #if 0
      static const real_t limiterBandsPerOctave[] = { REAL_CONST(1.2),
          REAL_CONST(2), REAL_CONST(3) };
  #else
      static const real_t limiterBandsCompare[] = { REAL_CONST(1.327152),
          REAL_CONST(1.185093), REAL_CONST(1.119872) };
  #endif
      uint8_t k, s;
      int8_t nrLim;
  #if 0
      real_t limBands;
  #endif

      sbr->f_table_lim[0][0] = sbr->f_table_res[LO_RES][0] - sbr->kx;
      sbr->f_table_lim[0][1] = sbr->f_table_res[LO_RES][sbr->N_low] - sbr->kx;
      sbr->N_L[0] = 1;

  #if 0
      printf("f_table_lim[%d][%d]: ", 0, sbr->N_L[0]);
      for (k = 0; k <= sbr->N_L[0]; k++)
      {
          printf("%d ", sbr->f_table_lim[0][k]);
      }
      printf("\n");
  #endif

      for (s = 1; s < 4; s++)
      {
          int32_t limTable[100 /*TODO*/] = {0};
          uint8_t patchBorders[64/*??*/] = {0};

  #if 0
          limBands = limiterBandsPerOctave[s - 1];
  #endif

          patchBorders[0] = sbr->kx;
          for (k = 1; k <= sbr->noPatches; k++)
          {
              patchBorders[k] = patchBorders[k-1] + sbr->patchNoSubbands[k-1];
          }

          for (k = 0; k <= sbr->N_low; k++)
          {
              limTable[k] = sbr->f_table_res[LO_RES][k];
          }
          for (k = 1; k < sbr->noPatches; k++)
          {
              limTable[k+sbr->N_low] = patchBorders[k];
          }

          /* needed */
          qsort(limTable, sbr->noPatches + sbr->N_low, sizeof(limTable[0]), longcmp);
          k = 1;
          nrLim = sbr->noPatches + sbr->N_low - 1;

          if (nrLim < 0) // TODO: BIG FAT PROBLEM
              return;

  restart:
          if (k <= nrLim)
          {
              real_t nOctaves;

              if (limTable[k-1] != 0)
  #if 0
                  nOctaves = REAL_CONST(log((float)limTable[k]/(float)limTable[k-1])/log(2.0));
  #else
                  nOctaves = (real_t)limTable[k]/(real_t)limTable[k-1];
  #endif
              else
                  nOctaves = 0;

  #if 0
              if ((MUL_R(nOctaves,limBands)) < REAL_CONST(0.49))
  #else
              if (nOctaves < limiterBandsCompare[s - 1])
  #endif
              {
                  uint8_t i;
                  if (limTable[k] != limTable[k-1])
                  {
                      uint8_t found = 0, found2 = 0;
                      for (i = 0; i <= sbr->noPatches; i++)
                      {
                          if (limTable[k] == patchBorders[i])
                              found = 1;
                      }
                      if (found)
                      {
                          found2 = 0;
                          for (i = 0; i <= sbr->noPatches; i++)
                          {
                              if (limTable[k-1] == patchBorders[i])
                                  found2 = 1;
                          }
                          if (found2)
                          {
                              k++;
                              goto restart;
                          } else {
                              /* remove (k-1)th element */
                              limTable[k-1] = sbr->f_table_res[LO_RES][sbr->N_low];
                              qsort(limTable, sbr->noPatches + sbr->N_low, sizeof(limTable[0]), longcmp);
                              nrLim--;
                              goto restart;
                          }
                      }
                  }
                  /* remove kth element */
                  limTable[k] = sbr->f_table_res[LO_RES][sbr->N_low];
                  qsort(limTable, nrLim, sizeof(limTable[0]), longcmp);
                  nrLim--;
                  goto restart;
              } else {
                  k++;
                  goto restart;
              }
          }

          sbr->N_L[s] = nrLim;
          for (k = 0; k <= nrLim; k++)
          {
              sbr->f_table_lim[s][k] = limTable[k] - sbr->kx;
          }

  #if 0
          printf("f_table_lim[%d][%d]: ", s, sbr->N_L[s]);
          for (k = 0; k <= sbr->N_L[s]; k++)
          {
              printf("%d ", sbr->f_table_lim[s][k]);
          }
          printf("\n");
  #endif
      }
  }
  /*}}}*/

  /*{{{*/
  sbr_info* sbrDecodeInit (uint16_t framelength, uint8_t id_aac, uint32_t sample_rate, uint8_t downSampledSBR ) {

      sbr_info *sbr = faad_malloc(sizeof(sbr_info));
      memset(sbr, 0, sizeof(sbr_info));

      /* save id of the parent element */
      sbr->id_aac = id_aac;
      sbr->sample_rate = sample_rate;

      sbr->bs_freq_scale = 2;
      sbr->bs_alter_scale = 1;
      sbr->bs_noise_bands = 2;
      sbr->bs_limiter_bands = 2;
      sbr->bs_limiter_gains = 2;
      sbr->bs_interpol_freq = 1;
      sbr->bs_smoothing_mode = 1;
      sbr->bs_start_freq = 5;
      sbr->bs_amp_res = 1;
      sbr->bs_samplerate_mode = 1;
      sbr->prevEnvIsShort[0] = -1;
      sbr->prevEnvIsShort[1] = -1;
      sbr->header_count = 0;
      sbr->Reset = 1;

      sbr->tHFGen = T_HFGEN;
      sbr->tHFAdj = T_HFADJ;

      sbr->bsco = 0;
      sbr->bsco_prev = 0;
      sbr->M_prev = 0;
      sbr->frame_len = framelength;

      /* force sbr reset */
      sbr->bs_start_freq_prev = -1;

      if (framelength == 960)
      {
          sbr->numTimeSlotsRate = RATE * NO_TIME_SLOTS_960;
          sbr->numTimeSlots = NO_TIME_SLOTS_960;
      } else {
          sbr->numTimeSlotsRate = RATE * NO_TIME_SLOTS;
          sbr->numTimeSlots = NO_TIME_SLOTS;
      }

      sbr->GQ_ringbuf_index[0] = 0;
      sbr->GQ_ringbuf_index[1] = 0;

      if (id_aac == ID_CPE)
      {
          /* stereo */
          uint8_t j;
          sbr->qmfa[0] = qmfa_init(32);
          sbr->qmfa[1] = qmfa_init(32);
          sbr->qmfs[0] = qmfs_init((downSampledSBR)?32:64);
          sbr->qmfs[1] = qmfs_init((downSampledSBR)?32:64);

          for (j = 0; j < 5; j++)
          {
              sbr->G_temp_prev[0][j] = faad_malloc(64*sizeof(real_t));
              sbr->G_temp_prev[1][j] = faad_malloc(64*sizeof(real_t));
              sbr->Q_temp_prev[0][j] = faad_malloc(64*sizeof(real_t));
              sbr->Q_temp_prev[1][j] = faad_malloc(64*sizeof(real_t));
          }

          memset(sbr->Xsbr[0], 0, (sbr->numTimeSlotsRate+sbr->tHFGen)*64 * sizeof(qmf_t));
          memset(sbr->Xsbr[1], 0, (sbr->numTimeSlotsRate+sbr->tHFGen)*64 * sizeof(qmf_t));
      } else {
          /* mono */
          uint8_t j;
          sbr->qmfa[0] = qmfa_init(32);
          sbr->qmfs[0] = qmfs_init((downSampledSBR)?32:64);
          sbr->qmfs[1] = NULL;

          for (j = 0; j < 5; j++)
          {
              sbr->G_temp_prev[0][j] = faad_malloc(64*sizeof(real_t));
              sbr->Q_temp_prev[0][j] = faad_malloc(64*sizeof(real_t));
          }

          memset(sbr->Xsbr[0], 0, (sbr->numTimeSlotsRate+sbr->tHFGen)*64 * sizeof(qmf_t));
      }

      return sbr;
  }
  /*}}}*/
  /*{{{*/
  void sbrDecodeEnd (sbr_info *sbr)
  {
      uint8_t j;

      if (sbr)
      {
          qmfa_end(sbr->qmfa[0]);
          qmfs_end(sbr->qmfs[0]);
          if (sbr->qmfs[1] != NULL)
          {
              qmfa_end(sbr->qmfa[1]);
              qmfs_end(sbr->qmfs[1]);
          }

          for (j = 0; j < 5; j++)
          {
              if (sbr->G_temp_prev[0][j]) faad_free(sbr->G_temp_prev[0][j]);
              if (sbr->Q_temp_prev[0][j]) faad_free(sbr->Q_temp_prev[0][j]);
              if (sbr->G_temp_prev[1][j]) faad_free(sbr->G_temp_prev[1][j]);
              if (sbr->Q_temp_prev[1][j]) faad_free(sbr->Q_temp_prev[1][j]);
          }

  #ifdef PS_DEC
          if (sbr->ps != NULL)
              ps_free(sbr->ps);
  #endif

          faad_free(sbr);
      }
  }
  /*}}}*/

  /*{{{*/
  void sbrReset (sbr_info *sbr)
  {
      uint8_t j;
      if (sbr->qmfa[0] != NULL)
          memset(sbr->qmfa[0]->x, 0, 2 * sbr->qmfa[0]->channels * 10 * sizeof(real_t));
      if (sbr->qmfa[1] != NULL)
          memset(sbr->qmfa[1]->x, 0, 2 * sbr->qmfa[1]->channels * 10 * sizeof(real_t));
      if (sbr->qmfs[0] != NULL)
          memset(sbr->qmfs[0]->v, 0, 2 * sbr->qmfs[0]->channels * 20 * sizeof(real_t));
      if (sbr->qmfs[1] != NULL)
          memset(sbr->qmfs[1]->v, 0, 2 * sbr->qmfs[1]->channels * 20 * sizeof(real_t));

      for (j = 0; j < 5; j++)
      {
          if (sbr->G_temp_prev[0][j] != NULL)
              memset(sbr->G_temp_prev[0][j], 0, 64*sizeof(real_t));
          if (sbr->G_temp_prev[1][j] != NULL)
              memset(sbr->G_temp_prev[1][j], 0, 64*sizeof(real_t));
          if (sbr->Q_temp_prev[0][j] != NULL)
              memset(sbr->Q_temp_prev[0][j], 0, 64*sizeof(real_t));
          if (sbr->Q_temp_prev[1][j] != NULL)
              memset(sbr->Q_temp_prev[1][j], 0, 64*sizeof(real_t));
      }

      memset(sbr->Xsbr[0], 0, (sbr->numTimeSlotsRate+sbr->tHFGen)*64 * sizeof(qmf_t));
      memset(sbr->Xsbr[1], 0, (sbr->numTimeSlotsRate+sbr->tHFGen)*64 * sizeof(qmf_t));

      sbr->GQ_ringbuf_index[0] = 0;
      sbr->GQ_ringbuf_index[1] = 0;
      sbr->header_count = 0;
      sbr->Reset = 1;

      sbr->L_E_prev[0] = 0;
      sbr->L_E_prev[1] = 0;
      sbr->bs_freq_scale = 2;
      sbr->bs_alter_scale = 1;
      sbr->bs_noise_bands = 2;
      sbr->bs_limiter_bands = 2;
      sbr->bs_limiter_gains = 2;
      sbr->bs_interpol_freq = 1;
      sbr->bs_smoothing_mode = 1;
      sbr->bs_start_freq = 5;
      sbr->bs_amp_res = 1;
      sbr->bs_samplerate_mode = 1;
      sbr->prevEnvIsShort[0] = -1;
      sbr->prevEnvIsShort[1] = -1;
      sbr->bsco = 0;
      sbr->bsco_prev = 0;
      sbr->M_prev = 0;
      sbr->bs_start_freq_prev = -1;

      sbr->f_prev[0] = 0;
      sbr->f_prev[1] = 0;
      for (j = 0; j < MAX_M; j++)
      {
          sbr->E_prev[0][j] = 0;
          sbr->Q_prev[0][j] = 0;
          sbr->E_prev[1][j] = 0;
          sbr->Q_prev[1][j] = 0;
          sbr->bs_add_harmonic_prev[0][j] = 0;
          sbr->bs_add_harmonic_prev[1][j] = 0;
      }
      sbr->bs_add_harmonic_flag_prev[0] = 0;
      sbr->bs_add_harmonic_flag_prev[1] = 0;
  }
  /*}}}*/
  /*{{{*/
  uint8_t sbrDecodeCoupleFrame (sbr_info *sbr, real_t *left_chan, real_t *right_chan,
                               const uint8_t just_seeked, const uint8_t downSampledSBR)
  {
      uint8_t dont_process = 0;
      uint8_t ret = 0;
      ALIGN qmf_t X[MAX_NTSR][64];

      if (sbr == NULL)
          return 20;

      /* case can occur due to bit errors */
      if (sbr->id_aac != ID_CPE)
          return 21;

      if (sbr->ret || (sbr->header_count == 0))
      {
          /* don't process just upsample */
          dont_process = 1;

          /* Re-activate reset for next frame */
          if (sbr->ret && sbr->Reset)
              sbr->bs_start_freq_prev = -1;
      }

      if (just_seeked)
      {
          sbr->just_seeked = 1;
      } else {
          sbr->just_seeked = 0;
      }

      sbr->ret += sbr_process_channel(sbr, left_chan, X, 0, dont_process, downSampledSBR);
      /* subband synthesis */
      if (downSampledSBR)
      {
          sbr_qmf_synthesis_32(sbr, sbr->qmfs[0], X, left_chan);
      } else {
          sbr_qmf_synthesis_64(sbr, sbr->qmfs[0], X, left_chan);
      }

      sbr->ret += sbr_process_channel(sbr, right_chan, X, 1, dont_process, downSampledSBR);
      /* subband synthesis */
      if (downSampledSBR)
      {
          sbr_qmf_synthesis_32(sbr, sbr->qmfs[1], X, right_chan);
      } else {
          sbr_qmf_synthesis_64(sbr, sbr->qmfs[1], X, right_chan);
      }

      if (sbr->bs_header_flag)
          sbr->just_seeked = 0;

      if (sbr->header_count != 0 && sbr->ret == 0)
      {
          ret = sbr_save_prev_data(sbr, 0);
          if (ret) return ret;
          ret = sbr_save_prev_data(sbr, 1);
          if (ret) return ret;
      }

      sbr_save_matrix(sbr, 0);
      sbr_save_matrix(sbr, 1);

      sbr->frame++;

  //#define POST_QMF_PRINT
  #ifdef POST_QMF_PRINT
      {
          int i;
          for (i = 0; i < 2048; i++)
          {
              printf("%d\n", left_chan[i]);
          }
          for (i = 0; i < 2048; i++)
          {
              printf("%d\n", right_chan[i]);
          }
      }
  #endif

      return 0;
  }
  /*}}}*/
  /*{{{*/
  uint8_t sbrDecodeSingleFrame (sbr_info *sbr, real_t *channel,
                               const uint8_t just_seeked, const uint8_t downSampledSBR)
  {
      uint8_t dont_process = 0;
      uint8_t ret = 0;
      ALIGN qmf_t X[MAX_NTSR][64];

      if (sbr == NULL)
          return 20;

      /* case can occur due to bit errors */
      if (sbr->id_aac != ID_SCE && sbr->id_aac != ID_LFE)
          return 21;

      if (sbr->ret || (sbr->header_count == 0))
      {
          /* don't process just upsample */
          dont_process = 1;

          /* Re-activate reset for next frame */
          if (sbr->ret && sbr->Reset)
              sbr->bs_start_freq_prev = -1;
      }

      if (just_seeked)
      {
          sbr->just_seeked = 1;
      } else {
          sbr->just_seeked = 0;
      }

      sbr->ret += sbr_process_channel(sbr, channel, X, 0, dont_process, downSampledSBR);
      /* subband synthesis */
      if (downSampledSBR)
      {
          sbr_qmf_synthesis_32(sbr, sbr->qmfs[0], X, channel);
      } else {
          sbr_qmf_synthesis_64(sbr, sbr->qmfs[0], X, channel);
      }

      if (sbr->bs_header_flag)
          sbr->just_seeked = 0;

      if (sbr->header_count != 0 && sbr->ret == 0)
      {
          ret = sbr_save_prev_data(sbr, 0);
          if (ret) return ret;
      }

      sbr_save_matrix(sbr, 0);

      sbr->frame++;

  //#define POST_QMF_PRINT
  #ifdef POST_QMF_PRINT
      {
          int i;
          for (i = 0; i < 2048; i++)
          {
              printf("%d\n", channel[i]);
          }
      }
  #endif

      return 0;
  }
  /*}}}*/

  #ifdef PS_DEC
    /*{{{*/
    uint8_t sbrDecodeSingleFramePS (sbr_info *sbr, real_t *left_channel, real_t *right_channel,
                                   const uint8_t just_seeked, const uint8_t downSampledSBR)
    {
        uint8_t l, k;
        uint8_t dont_process = 0;
        uint8_t ret = 0;
        ALIGN qmf_t X_left[38][64] = {{0}};
        ALIGN qmf_t X_right[38][64] = {{0}}; /* must set this to 0 */

        if (sbr == NULL)
            return 20;

        /* case can occur due to bit errors */
        if (sbr->id_aac != ID_SCE && sbr->id_aac != ID_LFE)
            return 21;

        if (sbr->ret || (sbr->header_count == 0))
        {
            /* don't process just upsample */
            dont_process = 1;

            /* Re-activate reset for next frame */
            if (sbr->ret && sbr->Reset)
                sbr->bs_start_freq_prev = -1;
        }

        if (just_seeked)
        {
            sbr->just_seeked = 1;
        } else {
            sbr->just_seeked = 0;
        }

        if (sbr->qmfs[1] == NULL)
        {
            sbr->qmfs[1] = qmfs_init((downSampledSBR)?32:64);
        }

        sbr->ret += sbr_process_channel(sbr, left_channel, X_left, 0, dont_process, downSampledSBR);

        /* copy some extra data for PS */
        for (l = sbr->numTimeSlotsRate; l < sbr->numTimeSlotsRate + 6; l++)
        {
            for (k = 0; k < 5; k++)
            {
                QMF_RE(X_left[l][k]) = QMF_RE(sbr->Xsbr[0][sbr->tHFAdj+l][k]);
                QMF_IM(X_left[l][k]) = QMF_IM(sbr->Xsbr[0][sbr->tHFAdj+l][k]);
            }
        }

        /* perform parametric stereo */
    #ifdef PS_DEC
            ps_decode(sbr->ps, X_left, X_right);
    #endif

        /* subband synthesis */
        if (downSampledSBR)
        {
            sbr_qmf_synthesis_32(sbr, sbr->qmfs[0], X_left, left_channel);
            sbr_qmf_synthesis_32(sbr, sbr->qmfs[1], X_right, right_channel);
        } else {
            sbr_qmf_synthesis_64(sbr, sbr->qmfs[0], X_left, left_channel);
            sbr_qmf_synthesis_64(sbr, sbr->qmfs[1], X_right, right_channel);
        }

        if (sbr->bs_header_flag)
            sbr->just_seeked = 0;

        if (sbr->header_count != 0 && sbr->ret == 0)
        {
            ret = sbr_save_prev_data(sbr, 0);
            if (ret) return ret;
        }

        sbr_save_matrix(sbr, 0);

        sbr->frame++;

        return 0;
    }
    /*}}}*/
  #endif

  /*{{{*/
  static INLINE int16_t sbr_huff_dec(bitfile *ld, sbr_huff_tab t_huff)
  {
      uint8_t bit;
      int16_t index = 0;

      while (index >= 0)
      {
          bit = (uint8_t)faad_get1bit(ld);
          index = t_huff[index][bit];
      }

      return index + 64;
  }
  /*}}}*/

  /*{{{*/
  void extract_envelope_data(sbr_info *sbr, uint8_t ch)
  {
      uint8_t l, k;

      for (l = 0; l < sbr->L_E[ch]; l++)
      {
          if (sbr->bs_df_env[ch][l] == 0)
          {
              for (k = 1; k < sbr->n[sbr->f[ch][l]]; k++)
              {
                  sbr->E[ch][k][l] = sbr->E[ch][k - 1][l] + sbr->E[ch][k][l];
                  if (sbr->E[ch][k][l] < 0)
                      sbr->E[ch][k][l] = 0;
              }

          } else { /* bs_df_env == 1 */

              uint8_t g = (l == 0) ? sbr->f_prev[ch] : sbr->f[ch][l-1];
              int16_t E_prev;

              if (sbr->f[ch][l] == g)
              {
                  for (k = 0; k < sbr->n[sbr->f[ch][l]]; k++)
                  {
                      if (l == 0)
                          E_prev = sbr->E_prev[ch][k];
                      else
                          E_prev = sbr->E[ch][k][l - 1];

                      sbr->E[ch][k][l] = E_prev + sbr->E[ch][k][l];
                  }

              } else if ((g == 1) && (sbr->f[ch][l] == 0)) {
                  uint8_t i;

                  for (k = 0; k < sbr->n[sbr->f[ch][l]]; k++)
                  {
                      for (i = 0; i < sbr->N_high; i++)
                      {
                          if (sbr->f_table_res[HI_RES][i] == sbr->f_table_res[LO_RES][k])
                          {
                              if (l == 0)
                                  E_prev = sbr->E_prev[ch][i];
                              else
                                  E_prev = sbr->E[ch][i][l - 1];

                              sbr->E[ch][k][l] = E_prev + sbr->E[ch][k][l];
                          }
                      }
                  }

              } else if ((g == 0) && (sbr->f[ch][l] == 1)) {
                  uint8_t i;

                  for (k = 0; k < sbr->n[sbr->f[ch][l]]; k++)
                  {
                      for (i = 0; i < sbr->N_low; i++)
                      {
                          if ((sbr->f_table_res[LO_RES][i] <= sbr->f_table_res[HI_RES][k]) &&
                              (sbr->f_table_res[HI_RES][k] < sbr->f_table_res[LO_RES][i + 1]))
                          {
                              if (l == 0)
                                  E_prev = sbr->E_prev[ch][i];
                              else
                                  E_prev = sbr->E[ch][i][l - 1];

                              sbr->E[ch][k][l] = E_prev + sbr->E[ch][k][l];
                          }
                      }
                  }
              }
          }
      }
  }
  /*}}}*/
  /*{{{*/
  void extract_noise_floor_data(sbr_info *sbr, uint8_t ch)
  {
      uint8_t l, k;

      for (l = 0; l < sbr->L_Q[ch]; l++)
      {
          if (sbr->bs_df_noise[ch][l] == 0)
          {
              for (k = 1; k < sbr->N_Q; k++)
              {
                  sbr->Q[ch][k][l] = sbr->Q[ch][k][l] + sbr->Q[ch][k-1][l];
              }
          } else {
              if (l == 0)
              {
                  for (k = 0; k < sbr->N_Q; k++)
                  {
                      sbr->Q[ch][k][l] = sbr->Q_prev[ch][k] + sbr->Q[ch][k][0];
                  }
              } else {
                  for (k = 0; k < sbr->N_Q; k++)
                  {
                      sbr->Q[ch][k][l] = sbr->Q[ch][k][l - 1] + sbr->Q[ch][k][l];
                  }
              }
          }
      }
  }
  /*}}}*/

  /*{{{*/
  void envelope_noise_dequantisation(sbr_info *sbr, uint8_t ch)
  {
      if (sbr->bs_coupling == 0)
      {
          int16_t exp;
          uint8_t l, k;
          uint8_t amp = (sbr->amp_res[ch]) ? 0 : 1;

          for (l = 0; l < sbr->L_E[ch]; l++)
          {
              for (k = 0; k < sbr->n[sbr->f[ch][l]]; k++)
              {
                  /* +6 for the *64 and -10 for the /32 in the synthesis QMF (fixed)
                   * since this is a energy value: (x/32)^2 = (x^2)/1024
                   */
                  /* exp = (sbr->E[ch][k][l] >> amp) + 6; */
                  exp = (sbr->E[ch][k][l] >> amp);

                  if ((exp < 0) || (exp >= 64))
                  {
                      sbr->E_orig[ch][k][l] = 0;
                  } else {
                      sbr->E_orig[ch][k][l] = E_deq_tab[exp];

                      /* save half the table size at the cost of 1 multiply */
                      if (amp && (sbr->E[ch][k][l] & 1))
                      {
                          sbr->E_orig[ch][k][l] = MUL_C(sbr->E_orig[ch][k][l], COEF_CONST(1.414213562));
                      }
                  }
              }
          }

          for (l = 0; l < sbr->L_Q[ch]; l++)
          {
              for (k = 0; k < sbr->N_Q; k++)
              {
                  sbr->Q_div[ch][k][l] = calc_Q_div(sbr, ch, k, l);
                  sbr->Q_div2[ch][k][l] = calc_Q_div2(sbr, ch, k, l);
              }
          }
      }
  }
  /*}}}*/
  /*{{{*/
  static const real_t E_pan_tab[25] = {
      FRAC_CONST(0.000244081), FRAC_CONST(0.000488043),
      FRAC_CONST(0.00097561),  FRAC_CONST(0.00194932),
      FRAC_CONST(0.00389105),  FRAC_CONST(0.00775194),
      FRAC_CONST(0.0153846),   FRAC_CONST(0.030303),
      FRAC_CONST(0.0588235),   FRAC_CONST(0.111111),
      FRAC_CONST(0.2),         FRAC_CONST(0.333333),
      FRAC_CONST(0.5),         FRAC_CONST(0.666667),
      FRAC_CONST(0.8),         FRAC_CONST(0.888889),
      FRAC_CONST(0.941176),    FRAC_CONST(0.969697),
      FRAC_CONST(0.984615),    FRAC_CONST(0.992248),
      FRAC_CONST(0.996109),    FRAC_CONST(0.998051),
      FRAC_CONST(0.999024),    FRAC_CONST(0.999512),
      FRAC_CONST(0.999756)
  };
  /*}}}*/
  /*{{{*/
  void unmap_envelope_noise(sbr_info *sbr)
  {
      real_t tmp;
      int16_t exp0, exp1;
      uint8_t l, k;
      uint8_t amp0 = (sbr->amp_res[0]) ? 0 : 1;
      uint8_t amp1 = (sbr->amp_res[1]) ? 0 : 1;

      for (l = 0; l < sbr->L_E[0]; l++)
      {
          for (k = 0; k < sbr->n[sbr->f[0][l]]; k++)
          {
              /* +6: * 64 ; +1: * 2 ; */
              exp0 = (sbr->E[0][k][l] >> amp0) + 1;

              /* UN_MAP removed: (x / 4096) same as (x >> 12) */
              /* E[1] is always even so no need for compensating the divide by 2 with
               * an extra multiplication
               */
              /* exp1 = (sbr->E[1][k][l] >> amp1) - 12; */
              exp1 = (sbr->E[1][k][l] >> amp1);

              if ((exp0 < 0) || (exp0 >= 64) ||
                  (exp1 < 0) || (exp1 > 24))
              {
                  sbr->E_orig[1][k][l] = 0;
                  sbr->E_orig[0][k][l] = 0;
              } else {
                  tmp = E_deq_tab[exp0];
                  if (amp0 && (sbr->E[0][k][l] & 1))
                  {
                      tmp = MUL_C(tmp, COEF_CONST(1.414213562));
                  }

                  /* panning */
                  sbr->E_orig[0][k][l] = MUL_F(tmp, E_pan_tab[exp1]);
                  sbr->E_orig[1][k][l] = MUL_F(tmp, E_pan_tab[24 - exp1]);
              }
          }
      }

      for (l = 0; l < sbr->L_Q[0]; l++)
      {
          for (k = 0; k < sbr->N_Q; k++)
          {
              sbr->Q_div[0][k][l] = calc_Q_div(sbr, 0, k, l);
              sbr->Q_div[1][k][l] = calc_Q_div(sbr, 1, k, l);
              sbr->Q_div2[0][k][l] = calc_Q_div2(sbr, 0, k, l);
              sbr->Q_div2[1][k][l] = calc_Q_div2(sbr, 1, k, l);
          }
      }
  }
  /*}}}*/

  /*{{{*/
  /* table 10 */
  void sbr_envelope(bitfile *ld, sbr_info *sbr, uint8_t ch)
  {
      uint8_t env, band;
      int8_t delta = 0;
      sbr_huff_tab t_huff, f_huff;

      if ((sbr->L_E[ch] == 1) && (sbr->bs_frame_class[ch] == FIXFIX))
          sbr->amp_res[ch] = 0;
      else
          sbr->amp_res[ch] = sbr->bs_amp_res;

      if ((sbr->bs_coupling) && (ch == 1))
      {
          delta = 1;
          if (sbr->amp_res[ch])
          {
              t_huff = t_huffman_env_bal_3_0dB;
              f_huff = f_huffman_env_bal_3_0dB;
          } else {
              t_huff = t_huffman_env_bal_1_5dB;
              f_huff = f_huffman_env_bal_1_5dB;
          }
      } else {
          delta = 0;
          if (sbr->amp_res[ch])
          {
              t_huff = t_huffman_env_3_0dB;
              f_huff = f_huffman_env_3_0dB;
          } else {
              t_huff = t_huffman_env_1_5dB;
              f_huff = f_huffman_env_1_5dB;
          }
      }

      for (env = 0; env < sbr->L_E[ch]; env++)
      {
          if (sbr->bs_df_env[ch][env] == 0)
          {
              if ((sbr->bs_coupling == 1) && (ch == 1))
              {
                  if (sbr->amp_res[ch])
                  {
                      sbr->E[ch][0][env] = (uint16_t)(faad_getbits(ld, 5
                          DEBUGVAR(1,272,"sbr_envelope(): bs_data_env")) << delta);
                  } else {
                      sbr->E[ch][0][env] = (uint16_t)(faad_getbits(ld, 6
                          DEBUGVAR(1,273,"sbr_envelope(): bs_data_env")) << delta);
                  }
              } else {
                  if (sbr->amp_res[ch])
                  {
                      sbr->E[ch][0][env] = (uint16_t)(faad_getbits(ld, 6
                          DEBUGVAR(1,274,"sbr_envelope(): bs_data_env")) << delta);
                  } else {
                      sbr->E[ch][0][env] = (uint16_t)(faad_getbits(ld, 7
                          DEBUGVAR(1,275,"sbr_envelope(): bs_data_env")) << delta);
                  }
              }

              for (band = 1; band < sbr->n[sbr->f[ch][env]]; band++)
              {
                  sbr->E[ch][band][env] = (sbr_huff_dec(ld, f_huff) << delta);
              }

          } else {
              for (band = 0; band < sbr->n[sbr->f[ch][env]]; band++)
              {
                  sbr->E[ch][band][env] = (sbr_huff_dec(ld, t_huff) << delta);
              }
          }
      }

      extract_envelope_data(sbr, ch);
  }
  /*}}}*/
  /*{{{*/
  /* table 11 */
  void sbr_noise(bitfile *ld, sbr_info *sbr, uint8_t ch)
  {
      uint8_t noise, band;
      int8_t delta = 0;
      sbr_huff_tab t_huff, f_huff;

      if ((sbr->bs_coupling == 1) && (ch == 1))
      {
          delta = 1;
          t_huff = t_huffman_noise_bal_3_0dB;
          f_huff = f_huffman_env_bal_3_0dB;
      } else {
          delta = 0;
          t_huff = t_huffman_noise_3_0dB;
          f_huff = f_huffman_env_3_0dB;
      }

      for (noise = 0; noise < sbr->L_Q[ch]; noise++)
      {
          if(sbr->bs_df_noise[ch][noise] == 0)
          {
              if ((sbr->bs_coupling == 1) && (ch == 1))
              {
                  sbr->Q[ch][0][noise] = (faad_getbits(ld, 5
                      DEBUGVAR(1,276,"sbr_noise(): bs_data_noise")) << delta);
              } else {
                  sbr->Q[ch][0][noise] = (faad_getbits(ld, 5
                      DEBUGVAR(1,277,"sbr_noise(): bs_data_noise")) << delta);
              }
              for (band = 1; band < sbr->N_Q; band++)
              {
                  sbr->Q[ch][band][noise] = (sbr_huff_dec(ld, f_huff) << delta);
              }
          } else {
              for (band = 0; band < sbr->N_Q; band++)
              {
                  sbr->Q[ch][band][noise] = (sbr_huff_dec(ld, t_huff) << delta);
              }
          }
      }

      extract_noise_floor_data(sbr, ch);
  }
  /*}}}*/

  /*{{{*/
  static void sbr_reset (sbr_info *sbr)
  {
  #if 0
      printf("%d\n", sbr->bs_start_freq_prev);
      printf("%d\n", sbr->bs_stop_freq_prev);
      printf("%d\n", sbr->bs_freq_scale_prev);
      printf("%d\n", sbr->bs_alter_scale_prev);
      printf("%d\n", sbr->bs_xover_band_prev);
      printf("%d\n\n", sbr->bs_noise_bands_prev);
  #endif

      /* if these are different from the previous frame: Reset = 1 */
      if ((sbr->bs_start_freq != sbr->bs_start_freq_prev) ||
          (sbr->bs_stop_freq != sbr->bs_stop_freq_prev) ||
          (sbr->bs_freq_scale != sbr->bs_freq_scale_prev) ||
          (sbr->bs_alter_scale != sbr->bs_alter_scale_prev) ||
          (sbr->bs_xover_band != sbr->bs_xover_band_prev) ||
          (sbr->bs_noise_bands != sbr->bs_noise_bands_prev))
      {
          sbr->Reset = 1;
      } else {
          sbr->Reset = 0;
      }

      sbr->bs_start_freq_prev = sbr->bs_start_freq;
      sbr->bs_stop_freq_prev = sbr->bs_stop_freq;
      sbr->bs_freq_scale_prev = sbr->bs_freq_scale;
      sbr->bs_alter_scale_prev = sbr->bs_alter_scale;
      sbr->bs_xover_band_prev = sbr->bs_xover_band;
      sbr->bs_noise_bands_prev = sbr->bs_noise_bands;
  }
  /*}}}*/
  /*{{{*/
  static uint8_t calc_sbr_tables (sbr_info *sbr, uint8_t start_freq, uint8_t stop_freq,
                                 uint8_t samplerate_mode, uint8_t freq_scale,
                                 uint8_t alter_scale, uint8_t xover_band)
  {
      uint8_t result = 0;
      uint8_t k2;

      /* calculate the Master Frequency Table */
      sbr->k0 = qmf_start_channel(start_freq, samplerate_mode, sbr->sample_rate);
      k2 = qmf_stop_channel(stop_freq, sbr->sample_rate, sbr->k0);

      /* check k0 and k2 */
      if (sbr->sample_rate >= 48000)
      {
          if ((k2 - sbr->k0) > 32)
              result += 1;
      } else if (sbr->sample_rate <= 32000) {
          if ((k2 - sbr->k0) > 48)
              result += 1;
      } else { /* (sbr->sample_rate == 44100) */
          if ((k2 - sbr->k0) > 45)
              result += 1;
      }

      if (freq_scale == 0)
      {
          result += master_frequency_table_fs0(sbr, sbr->k0, k2, alter_scale);
      } else {
          result += master_frequency_table(sbr, sbr->k0, k2, freq_scale, alter_scale);
      }
      result += derived_frequency_table(sbr, xover_band, k2);

      result = (result > 0) ? 1 : 0;

      return result;
  }
  /*}}}*/
  /*{{{*/
  /* table 3 */
  static void sbr_header (bitfile *ld, sbr_info *sbr)
  {
      uint8_t bs_header_extra_1, bs_header_extra_2;

      sbr->header_count++;

      sbr->bs_amp_res = faad_get1bit(ld
          DEBUGVAR(1,203,"sbr_header(): bs_amp_res"));

      /* bs_start_freq and bs_stop_freq must define a fequency band that does
         not exceed 48 channels */
      sbr->bs_start_freq = (uint8_t)faad_getbits(ld, 4
          DEBUGVAR(1,204,"sbr_header(): bs_start_freq"));
      sbr->bs_stop_freq = (uint8_t)faad_getbits(ld, 4
          DEBUGVAR(1,205,"sbr_header(): bs_stop_freq"));
      sbr->bs_xover_band = (uint8_t)faad_getbits(ld, 3
          DEBUGVAR(1,206,"sbr_header(): bs_xover_band"));
      faad_getbits(ld, 2
          DEBUGVAR(1,207,"sbr_header(): bs_reserved_bits_hdr"));
      bs_header_extra_1 = (uint8_t)faad_get1bit(ld
          DEBUGVAR(1,208,"sbr_header(): bs_header_extra_1"));
      bs_header_extra_2 = (uint8_t)faad_get1bit(ld
          DEBUGVAR(1,209,"sbr_header(): bs_header_extra_2"));

      if (bs_header_extra_1)
      {
          sbr->bs_freq_scale = (uint8_t)faad_getbits(ld, 2
              DEBUGVAR(1,211,"sbr_header(): bs_freq_scale"));
          sbr->bs_alter_scale = (uint8_t)faad_get1bit(ld
              DEBUGVAR(1,212,"sbr_header(): bs_alter_scale"));
          sbr->bs_noise_bands = (uint8_t)faad_getbits(ld, 2
              DEBUGVAR(1,213,"sbr_header(): bs_noise_bands"));
      } else {
          /* Default values */
          sbr->bs_freq_scale = 2;
          sbr->bs_alter_scale = 1;
          sbr->bs_noise_bands = 2;
      }

      if (bs_header_extra_2)
      {
          sbr->bs_limiter_bands = (uint8_t)faad_getbits(ld, 2
              DEBUGVAR(1,214,"sbr_header(): bs_limiter_bands"));
          sbr->bs_limiter_gains = (uint8_t)faad_getbits(ld, 2
              DEBUGVAR(1,215,"sbr_header(): bs_limiter_gains"));
          sbr->bs_interpol_freq = (uint8_t)faad_get1bit(ld
              DEBUGVAR(1,216,"sbr_header(): bs_interpol_freq"));
          sbr->bs_smoothing_mode = (uint8_t)faad_get1bit(ld
              DEBUGVAR(1,217,"sbr_header(): bs_smoothing_mode"));
      } else {
          /* Default values */
          sbr->bs_limiter_bands = 2;
          sbr->bs_limiter_gains = 2;
          sbr->bs_interpol_freq = 1;
          sbr->bs_smoothing_mode = 1;
      }

  #if 0
      /* print the header to screen */
      printf("bs_amp_res: %d\n", sbr->bs_amp_res);
      printf("bs_start_freq: %d\n", sbr->bs_start_freq);
      printf("bs_stop_freq: %d\n", sbr->bs_stop_freq);
      printf("bs_xover_band: %d\n", sbr->bs_xover_band);
      if (bs_header_extra_1)
      {
          printf("bs_freq_scale: %d\n", sbr->bs_freq_scale);
          printf("bs_alter_scale: %d\n", sbr->bs_alter_scale);
          printf("bs_noise_bands: %d\n", sbr->bs_noise_bands);
      }
      if (bs_header_extra_2)
      {
          printf("bs_limiter_bands: %d\n", sbr->bs_limiter_bands);
          printf("bs_limiter_gains: %d\n", sbr->bs_limiter_gains);
          printf("bs_interpol_freq: %d\n", sbr->bs_interpol_freq);
          printf("bs_smoothing_mode: %d\n", sbr->bs_smoothing_mode);
      }
      printf("\n");
  #endif
  }
  /*}}}*/
  /*{{{*/
  /* integer log[2](x): input range [0,10) */
  static int8_t sbr_log2 (const int8_t val)
  {
      int8_t log2tab[] = { 0, 0, 1, 2, 2, 3, 3, 3, 3, 4 };
      if (val < 10 && val >= 0)
          return log2tab[val];
      else
          return 0;
  }
  /*}}}*/
  /*{{{*/
  /* table 8 */
  static void sbr_dtdf (bitfile *ld, sbr_info *sbr, uint8_t ch)
  {
      uint8_t i;

      for (i = 0; i < sbr->L_E[ch]; i++)
      {
          sbr->bs_df_env[ch][i] = faad_get1bit(ld
              DEBUGVAR(1,269,"sbr_dtdf(): bs_df_env"));
      }

      for (i = 0; i < sbr->L_Q[ch]; i++)
      {
          sbr->bs_df_noise[ch][i] = faad_get1bit(ld
              DEBUGVAR(1,270,"sbr_dtdf(): bs_df_noise"));
      }
  }
  /*}}}*/
  /*{{{*/
  /* table 9 */
  static void invf_mode (bitfile *ld, sbr_info *sbr, uint8_t ch)
  {
      uint8_t n;

      for (n = 0; n < sbr->N_Q; n++)
      {
          sbr->bs_invf_mode[ch][n] = (uint8_t)faad_getbits(ld, 2
              DEBUGVAR(1,271,"invf_mode(): bs_invf_mode"));
      }
  }
  /*}}}*/
  /*{{{*/
  /* table 12 */
  static void sinusoidal_coding (bitfile *ld, sbr_info *sbr, uint8_t ch)
  {
      uint8_t n;

      for (n = 0; n < sbr->N_high; n++)
      {
          sbr->bs_add_harmonic[ch][n] = faad_get1bit(ld
              DEBUGVAR(1,278,"sinusoidal_coding(): bs_add_harmonic"));
      }
  }
  /*}}}*/
  /*{{{*/
  /* table 7 */
  static uint8_t sbr_grid (bitfile *ld, sbr_info *sbr, uint8_t ch)
  {
      uint8_t i, env, rel, result;
      uint8_t bs_abs_bord, bs_abs_bord_1;
      uint8_t bs_num_env = 0;
      uint8_t saved_L_E = sbr->L_E[ch];
      uint8_t saved_L_Q = sbr->L_Q[ch];
      uint8_t saved_frame_class = sbr->bs_frame_class[ch];

      sbr->bs_frame_class[ch] = (uint8_t)faad_getbits(ld, 2
          DEBUGVAR(1,248,"sbr_grid(): bs_frame_class"));

      switch (sbr->bs_frame_class[ch])
      {
      case FIXFIX:
          i = (uint8_t)faad_getbits(ld, 2
              DEBUGVAR(1,249,"sbr_grid(): bs_num_env_raw"));

          bs_num_env = min(1 << i, 5);

          i = (uint8_t)faad_get1bit(ld
              DEBUGVAR(1,250,"sbr_grid(): bs_freq_res_flag"));
          for (env = 0; env < bs_num_env; env++)
              sbr->f[ch][env] = i;

          sbr->abs_bord_lead[ch] = 0;
          sbr->abs_bord_trail[ch] = sbr->numTimeSlots;
          sbr->n_rel_lead[ch] = bs_num_env - 1;
          sbr->n_rel_trail[ch] = 0;
          break;

      case FIXVAR:
          bs_abs_bord = (uint8_t)faad_getbits(ld, 2
              DEBUGVAR(1,251,"sbr_grid(): bs_abs_bord")) + sbr->numTimeSlots;
          bs_num_env = (uint8_t)faad_getbits(ld, 2
              DEBUGVAR(1,252,"sbr_grid(): bs_num_env")) + 1;

          for (rel = 0; rel < bs_num_env-1; rel++)
          {
              sbr->bs_rel_bord[ch][rel] = 2 * (uint8_t)faad_getbits(ld, 2
                  DEBUGVAR(1,253,"sbr_grid(): bs_rel_bord")) + 2;
          }
          i = sbr_log2(bs_num_env + 1);
          sbr->bs_pointer[ch] = (uint8_t)faad_getbits(ld, i
              DEBUGVAR(1,254,"sbr_grid(): bs_pointer"));

          for (env = 0; env < bs_num_env; env++)
          {
              sbr->f[ch][bs_num_env - env - 1] = (uint8_t)faad_get1bit(ld
                  DEBUGVAR(1,255,"sbr_grid(): bs_freq_res"));
          }

          sbr->abs_bord_lead[ch] = 0;
          sbr->abs_bord_trail[ch] = bs_abs_bord;
          sbr->n_rel_lead[ch] = 0;
          sbr->n_rel_trail[ch] = bs_num_env - 1;
          break;

      case VARFIX:
          bs_abs_bord = (uint8_t)faad_getbits(ld, 2
              DEBUGVAR(1,256,"sbr_grid(): bs_abs_bord"));
          bs_num_env = (uint8_t)faad_getbits(ld, 2
              DEBUGVAR(1,257,"sbr_grid(): bs_num_env")) + 1;

          for (rel = 0; rel < bs_num_env-1; rel++)
          {
              sbr->bs_rel_bord[ch][rel] = 2 * (uint8_t)faad_getbits(ld, 2
                  DEBUGVAR(1,258,"sbr_grid(): bs_rel_bord")) + 2;
          }
          i = sbr_log2(bs_num_env + 1);
          sbr->bs_pointer[ch] = (uint8_t)faad_getbits(ld, i
              DEBUGVAR(1,259,"sbr_grid(): bs_pointer"));

          for (env = 0; env < bs_num_env; env++)
          {
              sbr->f[ch][env] = (uint8_t)faad_get1bit(ld
                  DEBUGVAR(1,260,"sbr_grid(): bs_freq_res"));
          }

          sbr->abs_bord_lead[ch] = bs_abs_bord;
          sbr->abs_bord_trail[ch] = sbr->numTimeSlots;
          sbr->n_rel_lead[ch] = bs_num_env - 1;
          sbr->n_rel_trail[ch] = 0;
          break;

      case VARVAR:
          bs_abs_bord = (uint8_t)faad_getbits(ld, 2
              DEBUGVAR(1,261,"sbr_grid(): bs_abs_bord_0"));
          bs_abs_bord_1 = (uint8_t)faad_getbits(ld, 2
              DEBUGVAR(1,262,"sbr_grid(): bs_abs_bord_1")) + sbr->numTimeSlots;
          sbr->bs_num_rel_0[ch] = (uint8_t)faad_getbits(ld, 2
              DEBUGVAR(1,263,"sbr_grid(): bs_num_rel_0"));
          sbr->bs_num_rel_1[ch] = (uint8_t)faad_getbits(ld, 2
              DEBUGVAR(1,264,"sbr_grid(): bs_num_rel_1"));

          bs_num_env = min(5, sbr->bs_num_rel_0[ch] + sbr->bs_num_rel_1[ch] + 1);

          for (rel = 0; rel < sbr->bs_num_rel_0[ch]; rel++)
          {
              sbr->bs_rel_bord_0[ch][rel] = 2 * (uint8_t)faad_getbits(ld, 2
                  DEBUGVAR(1,265,"sbr_grid(): bs_rel_bord")) + 2;
          }
          for(rel = 0; rel < sbr->bs_num_rel_1[ch]; rel++)
          {
              sbr->bs_rel_bord_1[ch][rel] = 2 * (uint8_t)faad_getbits(ld, 2
                  DEBUGVAR(1,266,"sbr_grid(): bs_rel_bord")) + 2;
          }
          i = sbr_log2(sbr->bs_num_rel_0[ch] + sbr->bs_num_rel_1[ch] + 2);
          sbr->bs_pointer[ch] = (uint8_t)faad_getbits(ld, i
              DEBUGVAR(1,267,"sbr_grid(): bs_pointer"));

          for (env = 0; env < bs_num_env; env++)
          {
              sbr->f[ch][env] = (uint8_t)faad_get1bit(ld
                  DEBUGVAR(1,268,"sbr_grid(): bs_freq_res"));
          }

          sbr->abs_bord_lead[ch] = bs_abs_bord;
          sbr->abs_bord_trail[ch] = bs_abs_bord_1;
          sbr->n_rel_lead[ch] = sbr->bs_num_rel_0[ch];
          sbr->n_rel_trail[ch] = sbr->bs_num_rel_1[ch];
          break;
      }

      if (sbr->bs_frame_class[ch] == VARVAR)
          sbr->L_E[ch] = min(bs_num_env, 5);
      else
          sbr->L_E[ch] = min(bs_num_env, 4);

      if (sbr->L_E[ch] <= 0)
          return 1;

      if (sbr->L_E[ch] > 1)
          sbr->L_Q[ch] = 2;
      else
          sbr->L_Q[ch] = 1;

      /* TODO: this code can probably be integrated into the code above! */
      if ((result = envelope_time_border_vector(sbr, ch)) > 0)
      {
          sbr->bs_frame_class[ch] = saved_frame_class;
          sbr->L_E[ch] = saved_L_E;
          sbr->L_Q[ch] = saved_L_Q;
          return result;
      }
      noise_floor_time_border_vector(sbr, ch);

  #if 0
      for (env = 0; env < bs_num_env; env++)
      {
          printf("freq_res[ch:%d][env:%d]: %d\n", ch, env, sbr->f[ch][env]);
      }
  #endif

      return 0;
  }
  /*}}}*/
  /*{{{*/
  static uint16_t sbr_extension (bitfile *ld, sbr_info *sbr,
                                uint8_t bs_extension_id, uint16_t num_bits_left)
  {
  #ifdef PS_DEC
      uint8_t header;
      uint16_t ret;
  #endif

      switch (bs_extension_id)
      {
  #ifdef PS_DEC
      case EXTENSION_ID_PS:
          if (!sbr->ps)
          {
              sbr->ps = ps_init(get_sr_index(sbr->sample_rate), sbr->numTimeSlotsRate);
          }
          if (sbr->psResetFlag)
          {
              sbr->ps->header_read = 0;
          }
          ret = ps_data(sbr->ps, ld, &header);

          /* enable PS if and only if: a header has been decoded */
          if (sbr->ps_used == 0 && header == 1)
          {
              sbr->ps_used = 1;
          }

          if (header == 1)
          {
              sbr->psResetFlag = 0;
          }

          return ret;
  #endif
      default:
          sbr->bs_extension_data = (uint8_t)faad_getbits(ld, 6
              DEBUGVAR(1,279,"sbr_single_channel_element(): bs_extension_data"));
          return 6;
      }
  }
  /*}}}*/
  /*{{{*/
  /* table 5 */
  static uint8_t sbr_single_channel_element(bitfile *ld, sbr_info *sbr)
  {
      uint8_t result;

      if (faad_get1bit(ld
          DEBUGVAR(1,220,"sbr_single_channel_element(): bs_data_extra")))
      {
          faad_getbits(ld, 4
              DEBUGVAR(1,221,"sbr_single_channel_element(): bs_reserved_bits_data"));
      }

      if ((result = sbr_grid(ld, sbr, 0)) > 0)
          return result;

      sbr_dtdf(ld, sbr, 0);
      invf_mode(ld, sbr, 0);
      sbr_envelope(ld, sbr, 0);
      sbr_noise(ld, sbr, 0);

      memset(sbr->bs_add_harmonic[0], 0, 64*sizeof(uint8_t));

      sbr->bs_add_harmonic_flag[0] = faad_get1bit(ld
          DEBUGVAR(1,223,"sbr_single_channel_element(): bs_add_harmonic_flag[0]"));
      if (sbr->bs_add_harmonic_flag[0])
          sinusoidal_coding(ld, sbr, 0);

      sbr->bs_extended_data = faad_get1bit(ld
          DEBUGVAR(1,224,"sbr_single_channel_element(): bs_extended_data[0]"));

      if (sbr->bs_extended_data)
      {
          uint16_t nr_bits_left;
  #if (defined(PS_DEC))
          uint8_t ps_ext_read = 0;
  #endif
          uint16_t cnt = (uint16_t)faad_getbits(ld, 4
              DEBUGVAR(1,225,"sbr_single_channel_element(): bs_extension_size"));
          if (cnt == 15)
          {
              cnt += (uint16_t)faad_getbits(ld, 8
                  DEBUGVAR(1,226,"sbr_single_channel_element(): bs_esc_count"));
          }

          nr_bits_left = 8 * cnt;
          while (nr_bits_left > 7)
          {
              uint16_t tmp_nr_bits = 0;

              sbr->bs_extension_id = (uint8_t)faad_getbits(ld, 2
                  DEBUGVAR(1,227,"sbr_single_channel_element(): bs_extension_id"));
              tmp_nr_bits += 2;

              /* allow only 1 PS extension element per extension data */
  #if (defined(PS_DEC))
    #ifdef PS_DEC
       if (sbr->bs_extension_id == EXTENSION_ID_PS)
    #endif
              {
                  if (ps_ext_read == 0)
                  {
                      ps_ext_read = 1;
                  } else {
                      /* to be safe make it 3, will switch to "default"
                       * in sbr_extension() */
                      sbr->bs_extension_id = 3;
                  }
              }
  #endif

              tmp_nr_bits += sbr_extension(ld, sbr, sbr->bs_extension_id, nr_bits_left);

              /* check if the data read is bigger than the number of available bits */
              if (tmp_nr_bits > nr_bits_left)
                  return 1;

              nr_bits_left -= tmp_nr_bits;
          }

          /* Corrigendum */
          if (nr_bits_left > 0)
          {
              faad_getbits(ld, nr_bits_left
                  DEBUGVAR(1,280,"sbr_single_channel_element(): nr_bits_left"));
          }
      }

      return 0;
  }
  /*}}}*/
  /*{{{*/
  /* table 6 */
  static uint8_t sbr_channel_pair_element (bitfile *ld, sbr_info *sbr)
  {
      uint8_t n, result;

      if (faad_get1bit(ld
          DEBUGVAR(1,228,"sbr_single_channel_element(): bs_data_extra")))
      {
          faad_getbits(ld, 4
              DEBUGVAR(1,228,"sbr_channel_pair_element(): bs_reserved_bits_data"));
          faad_getbits(ld, 4
              DEBUGVAR(1,228,"sbr_channel_pair_element(): bs_reserved_bits_data"));
      }

      sbr->bs_coupling = faad_get1bit(ld
          DEBUGVAR(1,228,"sbr_channel_pair_element(): bs_coupling"));

      if (sbr->bs_coupling)
      {
          if ((result = sbr_grid(ld, sbr, 0)) > 0)
              return result;

          /* need to copy some data from left to right */
          sbr->bs_frame_class[1] = sbr->bs_frame_class[0];
          sbr->L_E[1] = sbr->L_E[0];
          sbr->L_Q[1] = sbr->L_Q[0];
          sbr->bs_pointer[1] = sbr->bs_pointer[0];

          for (n = 0; n <= sbr->L_E[0]; n++)
          {
              sbr->t_E[1][n] = sbr->t_E[0][n];
              sbr->f[1][n] = sbr->f[0][n];
          }
          for (n = 0; n <= sbr->L_Q[0]; n++)
              sbr->t_Q[1][n] = sbr->t_Q[0][n];

          sbr_dtdf(ld, sbr, 0);
          sbr_dtdf(ld, sbr, 1);
          invf_mode(ld, sbr, 0);

          /* more copying */
          for (n = 0; n < sbr->N_Q; n++)
              sbr->bs_invf_mode[1][n] = sbr->bs_invf_mode[0][n];

          sbr_envelope(ld, sbr, 0);
          sbr_noise(ld, sbr, 0);
          sbr_envelope(ld, sbr, 1);
          sbr_noise(ld, sbr, 1);

          memset(sbr->bs_add_harmonic[0], 0, 64*sizeof(uint8_t));
          memset(sbr->bs_add_harmonic[1], 0, 64*sizeof(uint8_t));

          sbr->bs_add_harmonic_flag[0] = faad_get1bit(ld
              DEBUGVAR(1,231,"sbr_channel_pair_element(): bs_add_harmonic_flag[0]"));
          if (sbr->bs_add_harmonic_flag[0])
              sinusoidal_coding(ld, sbr, 0);

          sbr->bs_add_harmonic_flag[1] = faad_get1bit(ld
              DEBUGVAR(1,232,"sbr_channel_pair_element(): bs_add_harmonic_flag[1]"));
          if (sbr->bs_add_harmonic_flag[1])
              sinusoidal_coding(ld, sbr, 1);
      } else {
          uint8_t saved_t_E[6] = {0}, saved_t_Q[3] = {0};
          uint8_t saved_L_E = sbr->L_E[0];
          uint8_t saved_L_Q = sbr->L_Q[0];
          uint8_t saved_frame_class = sbr->bs_frame_class[0];

          for (n = 0; n < saved_L_E; n++)
              saved_t_E[n] = sbr->t_E[0][n];
          for (n = 0; n < saved_L_Q; n++)
              saved_t_Q[n] = sbr->t_Q[0][n];

          if ((result = sbr_grid(ld, sbr, 0)) > 0)
              return result;
          if ((result = sbr_grid(ld, sbr, 1)) > 0)
          {
              /* restore first channel data as well */
              sbr->bs_frame_class[0] = saved_frame_class;
              sbr->L_E[0] = saved_L_E;
              sbr->L_Q[0] = saved_L_Q;
              for (n = 0; n < 6; n++)
                  sbr->t_E[0][n] = saved_t_E[n];
              for (n = 0; n < 3; n++)
                  sbr->t_Q[0][n] = saved_t_Q[n];

              return result;
          }
          sbr_dtdf(ld, sbr, 0);
          sbr_dtdf(ld, sbr, 1);
          invf_mode(ld, sbr, 0);
          invf_mode(ld, sbr, 1);
          sbr_envelope(ld, sbr, 0);
          sbr_envelope(ld, sbr, 1);
          sbr_noise(ld, sbr, 0);
          sbr_noise(ld, sbr, 1);

          memset(sbr->bs_add_harmonic[0], 0, 64*sizeof(uint8_t));
          memset(sbr->bs_add_harmonic[1], 0, 64*sizeof(uint8_t));

          sbr->bs_add_harmonic_flag[0] = faad_get1bit(ld
              DEBUGVAR(1,239,"sbr_channel_pair_element(): bs_add_harmonic_flag[0]"));
          if (sbr->bs_add_harmonic_flag[0])
              sinusoidal_coding(ld, sbr, 0);

          sbr->bs_add_harmonic_flag[1] = faad_get1bit(ld
              DEBUGVAR(1,240,"sbr_channel_pair_element(): bs_add_harmonic_flag[1]"));
          if (sbr->bs_add_harmonic_flag[1])
              sinusoidal_coding(ld, sbr, 1);
      }
      envelope_noise_dequantisation(sbr, 0);
      envelope_noise_dequantisation(sbr, 1);

      if (sbr->bs_coupling)
          unmap_envelope_noise(sbr);

      sbr->bs_extended_data = faad_get1bit(ld
          DEBUGVAR(1,233,"sbr_channel_pair_element(): bs_extended_data[0]"));
      if (sbr->bs_extended_data)
      {
          uint16_t nr_bits_left;
          uint16_t cnt = (uint16_t)faad_getbits(ld, 4
              DEBUGVAR(1,234,"sbr_channel_pair_element(): bs_extension_size"));
          if (cnt == 15)
          {
              cnt += (uint16_t)faad_getbits(ld, 8
                  DEBUGVAR(1,235,"sbr_channel_pair_element(): bs_esc_count"));
          }

          nr_bits_left = 8 * cnt;
          while (nr_bits_left > 7)
          {
              uint16_t tmp_nr_bits = 0;

              sbr->bs_extension_id = (uint8_t)faad_getbits(ld, 2
                  DEBUGVAR(1,236,"sbr_channel_pair_element(): bs_extension_id"));
              tmp_nr_bits += 2;
              tmp_nr_bits += sbr_extension(ld, sbr, sbr->bs_extension_id, nr_bits_left);

              /* check if the data read is bigger than the number of available bits */
              if (tmp_nr_bits > nr_bits_left)
                  return 1;

              nr_bits_left -= tmp_nr_bits;
          }

          /* Corrigendum */
          if (nr_bits_left > 0)
          {
              faad_getbits(ld, nr_bits_left
                  DEBUGVAR(1,280,"sbr_channel_pair_element(): nr_bits_left"));
          }
      }

      return 0;
  }
  /*}}}*/
  /*{{{*/
  /* table 4 */
  static uint8_t sbr_data (bitfile *ld, sbr_info *sbr)
  {
      uint8_t result;
  #if 0
      sbr->bs_samplerate_mode = faad_get1bit(ld
          DEBUGVAR(1,219,"sbr_data(): bs_samplerate_mode"));
  #endif

      sbr->rate = (sbr->bs_samplerate_mode) ? 2 : 1;

      switch (sbr->id_aac)
      {
      case ID_SCE:
      if ((result = sbr_single_channel_element(ld, sbr)) > 0)
        return result;
          break;
      case ID_CPE:
      if ((result = sbr_channel_pair_element(ld, sbr)) > 0)
        return result;
          break;
      }

    return 0;
  }
  /*}}}*/

  /*{{{*/
  static uint8_t middleBorder(sbr_info *sbr, uint8_t ch)
  {
      int8_t retval = 0;

      switch (sbr->bs_frame_class[ch])
      {
      case FIXFIX:
          retval = sbr->L_E[ch]/2;
          break;
      case VARFIX:
          if (sbr->bs_pointer[ch] == 0)
              retval = 1;
          else if (sbr->bs_pointer[ch] == 1)
              retval = sbr->L_E[ch] - 1;
          else
              retval = sbr->bs_pointer[ch] - 1;
          break;
      case FIXVAR:
      case VARVAR:
          if (sbr->bs_pointer[ch] > 1)
              retval = sbr->L_E[ch] + 1 - sbr->bs_pointer[ch];
          else
              retval = sbr->L_E[ch] - 1;
          break;
      }

      return (retval > 0) ? retval : 0;
  }
  /*}}}*/

  /*{{{*/
  /* function constructs new time border vector */
  /* first build into temp vector to be able to use previous vector on error */
  uint8_t envelope_time_border_vector(sbr_info *sbr, uint8_t ch)
  {
      uint8_t l, border, temp;
      uint8_t t_E_temp[6] = {0};

      t_E_temp[0] = sbr->rate * sbr->abs_bord_lead[ch];
      t_E_temp[sbr->L_E[ch]] = sbr->rate * sbr->abs_bord_trail[ch];

      switch (sbr->bs_frame_class[ch])
      {
      case FIXFIX:
          switch (sbr->L_E[ch])
          {
          case 4:
              temp = (sbr->numTimeSlots / 4);
              t_E_temp[3] = sbr->rate * 3 * temp;
              t_E_temp[2] = sbr->rate * 2 * temp;
              t_E_temp[1] = sbr->rate * temp;
              break;
          case 2:
              t_E_temp[1] = sbr->rate * (sbr->numTimeSlots / 2);
              break;
          default:
              break;
          }
          break;

      case FIXVAR:
          if (sbr->L_E[ch] > 1)
          {
              int8_t i = sbr->L_E[ch];
              border = sbr->abs_bord_trail[ch];

              for (l = 0; l < (sbr->L_E[ch] - 1); l++)
              {
                  if (border < sbr->bs_rel_bord[ch][l])
                      return 1;

                  border -= sbr->bs_rel_bord[ch][l];
                  t_E_temp[--i] = sbr->rate * border;
              }
          }
          break;

      case VARFIX:
          if (sbr->L_E[ch] > 1)
          {
              int8_t i = 1;
              border = sbr->abs_bord_lead[ch];

              for (l = 0; l < (sbr->L_E[ch] - 1); l++)
              {
                  border += sbr->bs_rel_bord[ch][l];

                  if (sbr->rate * border + sbr->tHFAdj > sbr->numTimeSlotsRate+sbr->tHFGen)
                      return 1;

                  t_E_temp[i++] = sbr->rate * border;
              }
          }
          break;

      case VARVAR:
          if (sbr->bs_num_rel_0[ch])
          {
              int8_t i = 1;
              border = sbr->abs_bord_lead[ch];

              for (l = 0; l < sbr->bs_num_rel_0[ch]; l++)
              {
                  border += sbr->bs_rel_bord_0[ch][l];

                  if (sbr->rate * border + sbr->tHFAdj > sbr->numTimeSlotsRate+sbr->tHFGen)
                      return 1;

                  t_E_temp[i++] = sbr->rate * border;
              }
          }

          if (sbr->bs_num_rel_1[ch])
          {
              int8_t i = sbr->L_E[ch];
              border = sbr->abs_bord_trail[ch];

              for (l = 0; l < sbr->bs_num_rel_1[ch]; l++)
              {
                  if (border < sbr->bs_rel_bord_1[ch][l])
                      return 1;

                  border -= sbr->bs_rel_bord_1[ch][l];
                  t_E_temp[--i] = sbr->rate * border;
              }
          }
          break;
      }

      /* no error occured, we can safely use this t_E vector */
      for (l = 0; l < 6; l++)
      {
          sbr->t_E[ch][l] = t_E_temp[l];
      }

      return 0;
  }
  /*}}}*/
  /*{{{*/
  void noise_floor_time_border_vector(sbr_info *sbr, uint8_t ch)
  {
      sbr->t_Q[ch][0] = sbr->t_E[ch][0];

      if (sbr->L_E[ch] == 1)
      {
          sbr->t_Q[ch][1] = sbr->t_E[ch][1];
          sbr->t_Q[ch][2] = 0;
      } else {
          uint8_t index = middleBorder(sbr, ch);
          sbr->t_Q[ch][1] = sbr->t_E[ch][index];
          sbr->t_Q[ch][2] = sbr->t_E[ch][sbr->L_E[ch]];
      }
  }
  /*}}}*/

  /*{{{*/
  /* table 2 */
  uint8_t sbr_extension_data(bitfile *ld, sbr_info *sbr, uint16_t cnt,
                             uint8_t psResetFlag)
  {
      uint8_t result = 0;
      uint16_t num_align_bits = 0;
      uint16_t num_sbr_bits1 = (uint16_t)faad_get_processed_bits(ld);
      uint16_t num_sbr_bits2;

      uint8_t saved_start_freq, saved_samplerate_mode;
      uint8_t saved_stop_freq, saved_freq_scale;
      uint8_t saved_alter_scale, saved_xover_band;

  #if (defined(PS_DEC))
      if (psResetFlag)
          sbr->psResetFlag = psResetFlag;
  #endif

      {
          uint8_t bs_extension_type = (uint8_t)faad_getbits(ld, 4
              DEBUGVAR(1,198,"sbr_bitstream(): bs_extension_type"));

          if (bs_extension_type == EXT_SBR_DATA_CRC)
          {
              sbr->bs_sbr_crc_bits = (uint16_t)faad_getbits(ld, 10
                  DEBUGVAR(1,199,"sbr_bitstream(): bs_sbr_crc_bits"));
          }
      }

      /* save old header values, in case the new ones are corrupted */
      saved_start_freq = sbr->bs_start_freq;
      saved_samplerate_mode = sbr->bs_samplerate_mode;
      saved_stop_freq = sbr->bs_stop_freq;
      saved_freq_scale = sbr->bs_freq_scale;
      saved_alter_scale = sbr->bs_alter_scale;
      saved_xover_band = sbr->bs_xover_band;

      sbr->bs_header_flag = faad_get1bit(ld
          DEBUGVAR(1,200,"sbr_bitstream(): bs_header_flag"));

      if (sbr->bs_header_flag)
          sbr_header(ld, sbr);

      /* Reset? */
      sbr_reset(sbr);

      /* first frame should have a header */
      //if (!(sbr->frame == 0 && sbr->bs_header_flag == 0))
      if (sbr->header_count != 0)
      {
          if (sbr->Reset || (sbr->bs_header_flag && sbr->just_seeked))
          {
              uint8_t rt = calc_sbr_tables(sbr, sbr->bs_start_freq, sbr->bs_stop_freq,
                  sbr->bs_samplerate_mode, sbr->bs_freq_scale,
                  sbr->bs_alter_scale, sbr->bs_xover_band);

              /* if an error occured with the new header values revert to the old ones */
              if (rt > 0)
              {
                  calc_sbr_tables(sbr, saved_start_freq, saved_stop_freq,
                      saved_samplerate_mode, saved_freq_scale,
                      saved_alter_scale, saved_xover_band);
              }
          }

          if (result == 0)
          {
              result = sbr_data(ld, sbr);

              /* sbr_data() returning an error means that there was an error in
                 envelope_time_border_vector().
                 In this case the old time border vector is saved and all the previous
                 data normally read after sbr_grid() is saved.
              */
              /* to be on the safe side, calculate old sbr tables in case of error */
              if ((result > 0) &&
                  (sbr->Reset || (sbr->bs_header_flag && sbr->just_seeked)))
              {
                  calc_sbr_tables(sbr, saved_start_freq, saved_stop_freq,
                      saved_samplerate_mode, saved_freq_scale,
                      saved_alter_scale, saved_xover_band);
              }

              /* we should be able to safely set result to 0 now, */
              /* but practise indicates this doesn't work well */
          }
      } else {
          result = 1;
      }

      num_sbr_bits2 = (uint16_t)faad_get_processed_bits(ld) - num_sbr_bits1;

      /* check if we read more bits then were available for sbr */
      if (8*cnt < num_sbr_bits2)
      {
          faad_resetbits(ld, num_sbr_bits1 + 8*cnt);
          num_sbr_bits2 = 8*cnt;

  #ifdef PS_DEC
          /* turn off PS for the unfortunate case that we randomly read some
           * PS data that looks correct */
          sbr->ps_used = 0;
  #endif

          /* Make sure it doesn't decode SBR in this frame, or we'll get glitches */
          return 1;
      }

      {
          /* -4 does not apply, bs_extension_type is re-read in this function */
          num_align_bits = 8*cnt /*- 4*/ - num_sbr_bits2;

          while (num_align_bits > 7)
          {
              faad_getbits(ld, 8
                  DEBUGVAR(1,999,"sbr_bitstream(): num_align_bits"));
              num_align_bits -= 8;
          }
          faad_getbits(ld, num_align_bits
              DEBUGVAR(1,999,"sbr_bitstream(): num_align_bits"));
      }

      return result;
  }
  /*}}}*/

#endif
